; Version 2.1
;
; This library exists to do RNG manipulation in TPT2. If you don't know what RNG manipulation is,
; you can find plenty of info on the web, but also this library is probably not for you.

; Stub needed to make the macros not error during the examples
{lua(function rng_code() end)}

; There are three sets of macros defined in this library. The first is the 2-part rng_init sequence:
#rng_init1 {lua(return rng_code("init1"))}
#rng_init2(label) {lua(return rng_code("init2",[[{label}]]))}
; To use these, place this sequence *immediately* before the event you want to manipulate.
; {rng_init1}
; {rng_init2(continue)}
; continue:
;
; The last one takes a label to goto to when it is done. You can define the label on the next
; line if you just want it to continue there. You can also use more complicated conditional
; expressions if you want.
;
; It is important that you run this in the same frame as the event you are trying to manipulate,
; ideally right before, so that other calls to the rng do not happen in-between.
;
; If you need to re-initialize the state, jump to :rng_reinit. Don't include this block twice,
; because you will get an error about duplicate labels.

; To simulate future rolls of the rng, use this macro:
#rng_next {lua(return rng_code("next"))}
; You will need to call this (at least) once before calling rng_getint. Every call to {rng_next}
; should correspond to one call to the RNG (generally via rnd()), except for the last one(s) which
; you want to save for the actual in-game event(s) that are rolling the RNG.

; This macro converts the simulated state to a 32-bit integer.
#rng_getint {lua(return rng_code("getint"))}
#rng_getdouble {lua(return rng_code("getdouble"))}
; Don't forget that you need one call to {rng_next} before the result will be valid.
; {rng_getint} will potentially be negative if the high bit is set. {rng_getdouble} avoids
; this issue by using a double, so the result will always be a non-negative integer.

; Return a float value between 0.0 and 1.0 (inclusive).
#rng_getuniform {lua(return rng_code("getuniform"))}
; This performs the same function as UnityEngine.Random.value. Although the number returned
; is a double because of TPT2 type limitations, it only has single-precision values.
; If you need to do math that accurately mimics single-precision game math, keep that in
; mind (you may need to use the vector type to keep the behavior consistent.)

; This simulates the same behavior as the rnd() function.
#rng_getrange(min, max) {lua(return rng_code("getrange",[[{min}]],[[{max}]]))}
; The range is inclusive. Just like with {rng_getint}, {rng_next} needs to be called
; before this is valid.

; ==========================================================================================
; ================================= IMPLEMENTATION DETAILS =================================
; ==========================================================================================

; Change this to "global" for debugging
#rng_local local


; The 128-bit state of the rng, stored as 4 stringified ints in 44 characters.
; With the introduction of the "xor" and "and" bitwise operations, it is best to compute this
; using native 32-bit integers. However, we need to operate on 4 of them at once, which
; means packing them in a string.
; The format is ll characters per number, just enough to hold "-2147483648", with smaller
; numbers being space-padded on the right. Using xorshift parlance, x[3]=t is the first
; number and x[0]=s is the last.
; This is used by {rng_next} to compute the next state, and {rng_getint} to convert to a number.
; You can copy this elsewhere and restore it later if you want to simulate multiple rng seeds at once.
:{rng_local} string rng_state


; The structure of the code is broken up into multiple Lua functions, to allow regular
; comments to explain them at the top of each. Lua functions are used to construct the code,
; instead of regular macros, so that we could define our user-visible macros such as
; {rng_init1}, {rng_next} etc. at the top without having to give the full implementation;
; instead, a stub implementation was given and then the function is re-implemented at the
; bottom of the file here. This allows us to use the macros freely in comments, since macros
; are always expanded, where otherwise we could not comment on them before they were defined.
; As a side benefit, before the full definition takes effect they will expand to nothing,
; which is very fast to evaluate.

; This constructs the code for the two rng_init macros.
; At a high level, {rng_init1} is a local.string.set, and {rng_init2()} is a goto.
;
; Setting the state is relatively straightforward: A value from rnd() is just converted to
; a string and padded. We can easily do this 4 times in one expression.
{lua(function rng_codeCacheSetInit(cache)\
  cache.init1 = [[\
rng_reinit: rng_state =\
  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . "          ", 0, 11) .\
  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . "          ", 0, 11) .\
  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . "          ", 0, 11) .\
  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . "          ", 0, 11)\
]]\
\
--[[\
There is an additional quirk where if the value is exactly 0, it indicates a condition\
where we have to restart the process. This is because the nature of rnd() is that it adds\
one to range_max, so there is a hole where both 0 and 2^32-1 map to the same value and\
we cannot distinguish them. Since this is very rare, we just restart in this case and roll\
again. This is the purpose of the second line.\
]]\
cache.init2 = [[\
goto(\
  if(contains(rng_state, "0          "), rng_reinit, EXTERNAL_LABEL)\
)\
]]\
;end\
)}

; Construct the {rng_getint} code. This is simply the last number in the state.
;
; Internally, getint() and getdouble() are functions so that we can use them in the
; implementation of rng_next. The pos will always be either 33 or 0 to select either s or t.
;
; {rng_getuniform} has a bit more to it, but also only uses 23 bits from rng_state.
; We use the vector type, which is a pair of single-precision numbers, to get accurate
; single-precision rounding for the calculation to mirror what Unity does.
{lua(function rng_codeCacheSetGetInt(cache)\
  cache.getint = function(pos)\
    return string.format("s2i(sub(rng_state, %s, 11), 0)", pos)\
  end\
  cache.getdouble = function(pos)\
    return "(i2d(" .. cache.getint(pos) .. " %^ -2147483648) + 2147483648.)"\
  end\
  cache.getuniform = "x(vec(i2d(" .. cache.getint(33) .. " %& 8388607), 0.) * vec(1.192093e-7, 0.))"\
;end\
)}

; Construct {rng_next}.
; This is simply Margsaglia's xorshift128, modified to deal with the fact
; that we're using a single 128-bit string and doing all the work in parallel.
; Bear in mind that the number indexing is "reversed," i.e. x[3] is rng_state[0..11].
; In pseudocode, xorshift128 is:
; x[3]..x[2]..x[1]..x[0] = rng_state
; s = x[0]
; t = x[3]
; t ^= t << 11
; t ^= t >> 8
; s ^= s >> 19
; rng_state = x[2]..x[1]..x[0].. t ^ s
;
; To do this simultaneuosly and in parallel, we want to compute:
; rng_state = rng_state[11..44] .. (
;   x[0] ^ (x[0] >> 19)                      ; s ^ (s >> 19)
; ^ x[3] ^ (x[3] << 11)                      ; t ^ (t << 11)
; ^ ((x[3] >> 8) ^ (x[3] << 3)) & 0xffffff   ; (t ^ (t << 11)) >> 8
; )
; Left-shifts can be accomplished by multiplying by a constant. Right-shifts are trickier:
; We can divide by a power of two, but negative values will copy the sign bit and round
; to zero, messing everything up. Instead, we use getdouble to operate on an unsigned
; version, and floor the result.
{lua(function rng_codeCacheSetNext(cache)\
  cache["next"] = "rng_state = sub(rng_state, 11, 33) . sub(" ..\
  cache.getint(33) .. " %^ d2i(floor(" ..\
  cache.getdouble(33) .. " / 524288.)) %^ " ..\
  cache.getint(0) .. " %^ " ..\
  cache.getint(0) .. " * 2048 %^ d2i(floor(" ..\
  cache.getdouble(0) .. " / 256.)) %^ (" ..\
  cache.getint(0) .. ' * 8) %& 16777215 . "          ", 0, 11)'\
;end\
)}

{lua(function rng_getrange(min, max)\
  local nmin = tonumber(min)\
  local nmax = tonumber(max)\
  local range\
  if nmin and nmax then\
    range = string.format("%.1f", nmax + 0.0 - nmin + 1)\
  else\
    range = string.format([[(i2d(%s) - i2d(%s) + 1.)]], max, min)\
  end\
  local modpart = string.format([[%s %% %s]], rng_codecache.getdouble(33), range)\
  if nmin then\
    if nmin == 0 then\
      return "d2i(" .. modpart .. ")"\
    end\
    return string.format("d2i(%.1f + %s)", nmin, modpart)\
  end\
  return string.format("d2i(i2d(%s) + %s)", min, modpart)\
;end\
)}

; Return the appropriate code (macro body) given the passed in "id". All this does is lookup
; the precomputed code and return that; if the code hasn't been computed yet, it calls the
; helper functions tha exist specifically to set that up.
; The one wrinkle is that the 3rd init macro has a parameter, and that is substituted in
; to the cached code here.
{lua(function rng_code(id, label, arg2)\
  if not rng_codecache then\
    rng_codecache = {}\
    rng_codeCacheSetInit(rng_codecache)\
    rng_codeCacheSetGetInt(rng_codecache)\
    rng_codeCacheSetNext(rng_codecache)\
  end\
  if id == "getrange" then\
    return rng_getrange(label, arg2)\
  end\
  if id == "getint" or id == "getdouble" then\
    return rng_codecache[id](33)\
  end\
  local res = rng_codecache[id]\
  if label then\
    return res:gsub("EXTERNAL_LABEL", label)\
  end\
  return res\
;end\
)}
