# RNG Manipulation Library

If you just want the example script that gets stacks of Rak's Curse, you can
get that here:

`D0S.RakStak 2 1 14`

```
7VnLctMwFP2VoiUEYyctYVrKlJYFa9od6TCyLLua2JJHj6adtgN/wC+w5CvoTPNjjPxoHEdO7DjpA5JF4shX177nnHt1bV0BgTiJpQC7X68ARJIwqo/BQNm2jQNMMSfICphkxB+4iFEhIZXJ2S5KfuyZb19ITmhgIUYlJFToQccJQubC0MrOBViW3G0PKIfDb0JCqcTMOf3d54pSQgPQASaXoqFLae8VHPrFWBMLV2JOIb+0SDYFIxbFkBPBaD7mvAtghK2IeSrElsbvHFuEevjCGIEvYhyGFodDcaS4wEaj7v5+GekKoG2jHa5p15+1y5HtSzbCPA9LCUwms1uGrC/BQ4ZgqDE0kiY1aYipHHbIiTyLsCQogb0w26SiwmzT/TivjOQ6ToFcjyk3TGB0dqaQQIyFHhvRdVHvfCgN9yqZb6IIp6adwd+SuaZH3iJGEcziIF3Rgjh3r5T6duoqJcosohE8x0e5iBynIKICva2HeSICQn1Cibw0k/pyManj3+ef+4dVgnWTi2AO1+RfJv41YBO6s2o4gkT6HEa4Zo30C2nkMhZWDpoSzk+T7QzDUJ6VbjbXcL2K2TZvMr/X1/Nqw0ZTtTRltnhvyGNjVZjk8RyK1tZzODu119inu6ysPj+6A1pzTZnTZWTkz1lSJKdBwg6eWVFMx1IoN/VmXoBM3URyj3pJ4tRbvCje/SjbjP+Mb8e334249y4YX8Ln9oBu3X9atYKuwW4D0gakDUgPBVLdtsm0fE3XR3PLfF8fTYC49pzA6hRwfw3Fe1o1bYKsVmbJ7kUFi3NVuuqxnuiSVQZvCmpJfGqKvJBlyYHXJQM/a938kKXDzdpfTYH3f0C2TGFSWa/evHcb//po9vZmGW9bZmcTKayYqLZVdzUCfwhJPmqkM095+XS3PkjPrwo8vriecymID5onzT/PqiGRFl8iAw7ONsK6xR3fppOW35tIU/OJJ+NmSbZ7ESsrYIG/g7uf5ixsu3W0XWFdVkKN54Qq4FSjB8BmTC+5WVGSc6u3hs1iMGzMgNMOQIx6ZGor1uml74TFiX5veIKF1Jshpx1AoliFAieGIzjEKgYdkNhSPOJMUU9bUf0Cfxd8so+tL3B4LOEQdEAM0RAGehx0gKu8AEuw+9rpACXwYfZXcoVvTm/+Ag==
```

It automatically starts in tower testing, will exit if you don't have Rak's Curse in your BP, and will also exit
as soon as it finished getting 5 stacks, which should only take a few seconds. Aside from the parts that are macro-generated
by the rng\_manip library, it should be pretty straightforward to understand and incorporate yourself if you want to.

It'll be easier to understand by looking at the [source code](D0S.RakStak.tpt2).

## Library workspace

To use the library yourself, you'll need to import the source. The workspace
import comes with three example scripts, which you can delete if you don't want/need.
Explanation for how to use the library is in the comments of the rnglib script.

```
{"workspaces":{"rng_manip":[["rnglib","; This library exists to do RNG manipulation in TPT2. If you don't know what RNG manipulation is,\n; you can find plenty of info on the web, but also this library is probably not for you.\n\n; Stub needed to make the macros not error during the examples\n{lua(function rng_code() end)}\n\n; There are three sets of macros defined in this library. The first is the 2-part rng_init sequence:\n#rng_init1 {lua(return rng_code(\"init1\"))}\n#rng_init2(label) {lua(return rng_code(\"init2\",[[{label}]]))}\n; To use these, place this sequence *immediately* before the event you want to manipulate.\n; {rng_init1}\n; {rng_init2(continue)}\n; continue:\n;\n; The last one takes a label to goto to when it is done. You can define the label on the next\n; line if you just want it to continue there. You can also use more complicated conditional\n; expressions if you want.\n;\n; It is important that you run this in the same frame as the event you are trying to manipulate,\n; ideally right before, so that other calls to the rng do not happen in-between.\n;\n; If you need to re-initialize the state, jump to :rng_reinit. Don't include this block twice,\n; because you will get an error about duplicate labels.\n\n; To simulate future rolls of the rng, use this macro:\n#rng_next {lua(return rng_code(\"next\"))}\n; You will need to call this (at least) once before calling rng_getint. Every call to {rng_next}\n; should correspond to one call to the RNG (generally via rnd()), except for the last one(s) which\n; you want to save for the actual in-game event(s) that are rolling the RNG.\n\n; This macro converts the simulated state to a 32-bit integer.\n#rng_getint {lua(return rng_code(\"getint\"))}\n#rng_getdouble {lua(return rng_code(\"getdouble\"))}\n; Don't forget that you need one call to {rng_next} before the result will be valid.\n; {rng_getint} will potentially be negative if the high bit is set. {rng_getdouble} avoids\n; this issue by using a double, so the result will always be a non-negative integer.\n\n; Return a float value between 0.0 and 1.0 (inclusive).\n#rng_getuniform {lua(return rng_code(\"getuniform\"))}\n; This performs the same function as UnityEngine.Random.value. Although the number returned\n; is a double because of TPT2 type limitations, it only has single-precision values.\n; If you need to do math that accurately mimics single-precision game math, keep that in\n; mind (you may need to use the vector type to keep the behavior consistent.)\n\n; This simulates the same behavior as the rnd() function.\n#rng_getrange(min, max) {lua(return rng_code(\"getrange\",[[{min}]],[[{max}]]))}\n; The range is inclusive. Just like with {rng_getint}, {rng_next} needs to be called\n; before this is valid.\n\n; ==========================================================================================\n; ================================= IMPLEMENTATION DETAILS =================================\n; ==========================================================================================\n\n; Change this to \"global\" for debugging\n#rng_local local\n\n\n; The 128-bit state of the rng, stored as 4 stringified ints in 44 characters.\n; With the introduction of the \"xor\" and \"and\" bitwise operations, it is best to compute this\n; using native 32-bit integers. However, we need to operate on 4 of them at once, which\n; means packing them in a string.\n; The format is ll characters per number, just enough to hold \"-2147483648\", with smaller\n; numbers being space-padded on the right. Using xorshift parlance, x[3]=t is the first\n; number and x[0]=s is the last.\n; This is used by {rng_next} to compute the next state, and {rng_getint} to convert to a number.\n; You can copy this elsewhere and restore it later if you want to simulate multiple rng seeds at once.\n:{rng_local} string rng_state\n\n\n; The structure of the code is broken up into multiple Lua functions, to allow regular\n; comments to explain them at the top of each. Lua functions are used to construct the code,\n; instead of regular macros, so that we could define our user-visible macros such as\n; {rng_init1}, {rng_next} etc. at the top without having to give the full implementation;\n; instead, a stub implementation was given and then the function is re-implemented at the\n; bottom of the file here. This allows us to use the macros freely in comments, since macros\n; are always expanded, where otherwise we could not comment on them before they were defined.\n; As a side benefit, before the full definition takes effect they will expand to nothing,\n; which is very fast to evaluate.\n\n; This constructs the code for the two rng_init macros.\n; At a high level, {rng_init1} is a local.string.set, and {rng_init2()} is a goto.\n;\n; Setting the state is relatively straightforward: A value from rnd() is just converted to\n; a string and padded. We can easily do this 4 times in one expression.\n{lua(function rng_codeCacheSetInit(cache)\\\n  cache.init1 = [[\\\nrng_reinit: rng_state =\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11) .\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11) .\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11) .\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11)\\\n]]\\\n\\\n--[[\\\nThere is an additional quirk where if the value is exactly 0, it indicates a condition\\\nwhere we have to restart the process. This is because the nature of rnd() is that it adds\\\none to range_max, so there is a hole where both 0 and 2^32-1 map to the same value and\\\nwe cannot distinguish them. Since this is very rare, we just restart in this case and roll\\\nagain. This is the purpose of the second line.\\\n]]\\\ncache.init2 = [[\\\ngoto(\\\n  if(contains(rng_state, \"0          \"), rng_reinit, EXTERNAL_LABEL)\\\n)\\\n]]\\\n;end\\\n)}\n\n; Construct the {rng_getint} code. This is simply the last number in the state.\n;\n; Internally, getint() and getdouble() are functions so that we can use them in the\n; implementation of rng_next. The pos will always be either 33 or 0 to select either s or t.\n;\n; {rng_getuniform} has a bit more to it, but also only uses 23 bits from rng_state.\n; We use the vector type, which is a pair of single-precision numbers, to get accurate\n; single-precision rounding for the calculation to mirror what Unity does.\n{lua(function rng_codeCacheSetGetInt(cache)\\\n  cache.getint = function(pos)\\\n    return string.format(\"s2i(sub(rng_state, %s, 11), 0)\", pos)\\\n  end\\\n  cache.getdouble = function(pos)\\\n    return \"(i2d(\" .. cache.getint(pos) .. \" %^ -2147483648) + 2147483648.)\"\\\n  end\\\n  cache.getuniform = \"x(vec(i2d(\" .. cache.getint(33) .. \" %& 8388607), 0.) * vec(1.192093e-7, 0.))\"\\\n;end\\\n)}\n\n; Construct {rng_next}.\n; This is simply Margsaglia's xorshift128, modified to deal with the fact\n; that we're using a single 128-bit string and doing all the work in parallel.\n; Bear in mind that the number indexing is \"reversed,\" i.e. x[3] is rng_state[0..11].\n; In pseudocode, xorshift128 is:\n; x[3]..x[2]..x[1]..x[0] = rng_state\n; s = x[0]\n; t = x[3]\n; t ^= t << 11\n; t ^= t >> 8\n; s ^= s >> 19\n; rng_state = x[2]..x[1]..x[0].. t ^ s\n;\n; To do this simultaneuosly and in parallel, we want to compute:\n; rng_state = rng_state[11..44] .. (\n;   x[0] ^ (x[0] >> 19)                      ; s ^ (s >> 19)\n; ^ x[3] ^ (x[3] << 11)                      ; t ^ (t << 11)\n; ^ ((x[3] >> 8) ^ (x[3] << 3)) & 0xffffff   ; (t ^ (t << 11)) >> 8\n; )\n; Left-shifts can be accomplished by multiplying by a constant. Right-shifts are trickier:\n; We can divide by a power of two, but negative values will copy the sign bit and round\n; to zero, messing everything up. Instead, we use getdouble to operate on an unsigned\n; version, and floor the result.\n{lua(function rng_codeCacheSetNext(cache)\\\n  cache[\"next\"] = \"rng_state = sub(rng_state, 11, 33) . (\" ..\\\n  cache.getint(33) .. \" %^ d2i(floor(\" ..\\\n  cache.getdouble(33) .. \" / 524288.)) %^ \" ..\\\n  cache.getint(0) .. \" %^ \" ..\\\n  cache.getint(0) .. \" * 2048 %^ d2i(floor(\" ..\\\n  cache.getdouble(0) .. \" / 256.)) %^ (\" ..\\\n  cache.getint(0) .. \" * 8) %& 16777215)\"\\\n;end\\\n)}\n\n{lua(function rng_getrange(min, max)\\\n  local nmin = tonumber(min)\\\n  local nmax = tonumber(max)\\\n  local range\\\n  if nmin and nmax then\\\n    range = string.format(\"%.1f\", nmax + 0.0 - nmin + 1)\\\n  else\\\n    range = string.format([[(i2d(%s) - i2d(%s) + 1.)]], max, min)\\\n  end\\\n  local modpart = string.format([[%s %% %s]], rng_codecache.getdouble(33), range)\\\n  if nmin then\\\n    if nmin == 0 then\\\n      return \"d2i(\" .. modpart .. \")\"\\\n    end\\\n    return string.format(\"d2i(%.1f + %s)\", nmin, modpart)\\\n  end\\\n  return string.format(\"d2i(i2d(%s) + %s)\", min, modpart)\\\n;end\\\n)}\n\n; Return the appropriate code (macro body) given the passed in \"id\". All this does is lookup\n; the precomputed code and return that; if the code hasn't been computed yet, it calls the\n; helper functions tha exist specifically to set that up.\n; The one wrinkle is that the 3rd init macro has a parameter, and that is substituted in\n; to the cached code here.\n{lua(function rng_code(id, label, arg2)\\\n  if not rng_codecache then\\\n    rng_codecache = {}\\\n    rng_codeCacheSetInit(rng_codecache)\\\n    rng_codeCacheSetGetInt(rng_codecache)\\\n    rng_codeCacheSetNext(rng_codecache)\\\n  end\\\n  if id == \"getrange\" then\\\n    return rng_getrange(label, arg2)\\\n  end\\\n  if id == \"getint\" or id == \"getdouble\" then\\\n    return rng_codecache[id](33)\\\n  end\\\n  local res = rng_codecache[id]\\\n  if label then\\\n    return res:gsub(\"EXTERNAL_LABEL\", label)\\\n  end\\\n  return res\\\n;end\\\n)}\n"],["rng_tester","key.t()\n\n:import rnglib\n:budget_cap max\n\n:global int predicted_rng\n:global int actual_rng\n\n{rng_init1}\n{rng_init2(guess)}\n\nguess:\n{rng_next}\npredicted_rng = {rng_getrange(0, 999999)}\nactual_rng = rnd(0, 999999)\n"],["D0S.RakStak","wakeup()\ngame.newround()\n\nisTowerTesting()\n\n:import rnglib\n:budget_cap max\n\n:local int rak_count\n:local double waveCount\n:global string rak_status\n\ngotoif(exit, contains(rak_status, \"running\"))\nrak_status = \"0;running\"\ngoto(if(\\\n  active.index(\"spell.raksCurse\") == 0,\\\n  end,\\\n  wait_for_rak\\\n))\n\ndo_rak:\nuseinstant(active.index(\"spell.raksCurse\"))\n; Don't increment if we didn't have mana\nrak_count += if(cooldown(active.index(\"spell.raksCurse\")) > 0., 1, 0)\nrak_status = rak_count . \";running\"\n\n#rawWaves (infinity() * 1e11 + era()) * 1e11 + wave()\nwait_for_rak:\nwaveCount = {rawWaves}\nwaitframe()\n; Abort if we exited or restarted or are finished with stacks\ngoto(if(\\\n  health(false) == 0. || {rawWaves} < waveCount || contains(rak_status, \"5\"),\\\n  end,\\\n  if(\\\n    cooldown(active.index(\"spell.raksCurse\")) == 0.,\\\n    rng_reinit,\\\n    wait_for_rak\\\n  )\\\n))\n\n{rng_init1}\n{rng_init2(guess)}\n\nguess:\n{rng_next}\ngoto(if(\\\n  {rng_getrange(0, 999)} == 0,\\\n  do_rak,\\\n  guess + rnd(0, 0)\\\n))\\\n\nend:\nrak_status = sub(rak_status, 0, 1)\nexit:\n"],["rng_testuniform","key.t()\n\n:import rnglib\n:budget_cap max\n\n:global double predicted_rng\n:global double actual_rng\n\n{rng_init1}\n{rng_init2(guess)}\n\nguess:\n{rng_next}\npredicted_rng = {rng_getuniform}\nactual_rng = rnd(0., 1.)\n"]]}}
```
