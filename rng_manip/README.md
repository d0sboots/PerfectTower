# RNG Manipulation Library

If you just want the example script that gets stacks of Rak's Curse, you can
get that here:

`D0S.RakStak 2 1 14`

```
7VnNbtpAEH6VdI8tdW1ISpU0VZr00HOTW4mq9XrtrDC7aH9CoiRq36Cv0GOfopHCi1VrTDBmDDaG/LRwADOeHXu++ebH3iukiGR9rdDu1yuEiWaC22PUMa7r0ohyKhlxIqEFCzs+EVxpzHVytkmSH3fmO1RaMh45RHCNGVdW6HlRLHwcO+m5iOqcue0Ol7j7TWmsjZo5Z7/b0nDOeIQaCDKpKprU7l7GYJj1NdHwNZUcy0uHpUsoEb0+lkwJPpZ57yLco05PBCamjsXvnDqMB/QC9CBUfRrHjsRddWSkoqBSc38/j3QB0C6oR0vqtWf1xsi2tRhQOXbLKMomq2u6bC8hY0FwbDEEg6Zt0IgwY9ixZPqsRzUjCeyZ1RCLMquh+/FegcH1vExwA2H8OIHR25lCgggRB2LA1xV670NO3CqMfBVGeCX1AHtL5pqVvCWCE5z6wZqqRuD8vVzquyNTo0DBJBrgc3o0JpHnZUiUCW9tsUxIwHjIONOXcFBfLg7q8Pf55/ZhEWH95CJU4jXZ14l9C9gk3Gk1HGCmQ4l7tGSNDDNp5AsRFwqhhAtHyXZGcazPcjc75nC5ilk3b1K719fzasOGU6U4BWu8B/IYrAqTPJ4TorXNHN5O6R77dNvK6vOj2eEle8qcKSMN/pyWoiWPkujQmY4CHWtl/JE1uAFB00Ryj7YlSR4sbop3P/I6wz/D2+HtdxD31oWQS9jc7vCt+0+tUdAH9DYgbUDagPRQIJUdm6D2NV0f4ZH5vj5CgPjuHMfKFPBwDcV7mjV1nCxmZk7vxQrJu2pZSzXZKjGBfF0StpLczyRfchA0WSdMJ7owFiNxtanYhiD4PyBbpl6ZdISvPtINf32Erb1ZxtoWbGxChRUHqm4xXg3BH4KSj+rpzMPfeLlfHqTnVwUen1zPuRT0D6onzT8fVSCRFl8iBQ7Pzsd28h3eFix6/BkW2B4ZlYEnnvib9u+2eiLPtgX2Du5+whlfd/dqu0A7z4QSjypFwJlKz6DVIr3kfkmOzrVeXFbzAdgbQqcNRAQP2NRusNcavZZWJ/bV5QlV2u7HnDYQ6/VNrGiiOMBdavqogRJdTgdSGB5YLW73EHbRJ/fY+YK7xxp3UQP1MeniyMpRA/kmiKhGu6+9BjKKHqZ/tTT05vTmLw==
```

It automatically starts in tower testing, will exit if you don't have Rak's Curse in your BP, and will also exit
as soon as it finished getting 5 stacks, which should only take a few seconds. Aside from the parts that are macro-generated
by the rng\_manip library, it should be pretty straightforward to understand and incorporate yourself if you want to.

It'll be easier to understand by looking at the [source code](D0S.RakStak.tpt2).

## Library workspace

To use the library yourself, you'll need to import the source. The workspace
import comes with three example scripts, which you can delete if you don't want/need.
Explanation for how to use the library is in the comments of the rnglib script.

```
{"workspaces":{"rng_manip":[["rnglib","; Version 2.2\n;\n; This library exists to do RNG manipulation in TPT2. If you don't know what RNG manipulation is,\n; you can find plenty of info on the web, but also this library is probably not for you.\n\n; Stub needed to make the macros not error during the examples\n{lua(function rng_code() end)}\n\n; There are three sets of macros defined in this library. The first is rng_init:\n#rng_init(label) {lua(return rng_code(\"init\",[[{label}]]))}\n; To use this, place this sequence *immediately* before the event you want to manipulate.\n; {rng_init(continue)}\n; continue:\n;\n; rng_init takes a label to goto when it is done. You can define the label on the next\n; line if you just want it to continue there. You can also use more complicated conditional\n; expressions if you want.\n;\n; It is important that you run this in the same frame as the event you are trying to manipulate,\n; ideally right before, so that other calls to the rng do not happen in-between.\n;\n; If you need to re-initialize the state, jump to :rng_reinit. Don't use this macro twice,\n; because you will get an error about duplicate labels. It expands to 2 lines and a label.\n\n; To simulate future rolls of the rng, use this macro:\n#rng_next {lua(return rng_code(\"next\"))}\n; You will need to call this (at least) once before calling rng_getint. Every call to {rng_next}\n; should correspond to one call to the RNG (generally via rnd()), except for the last one(s) which\n; you want to save for the actual in-game event(s) that are rolling the RNG.\n\n; This macro converts the simulated state to a 32-bit integer.\n#rng_getint {lua(return rng_code(\"getint\"))}\n#rng_getdouble {lua(return rng_code(\"getdouble\"))}\n; Don't forget that you need one call to {rng_next} before the result will be valid.\n; {rng_getint} will potentially be negative if the high bit is set. {rng_getdouble} avoids\n; this issue by using a double, so the result will always be a non-negative integer.\n\n; Return a float value between 0.0 and 1.0 (inclusive).\n#rng_getuniform {lua(return rng_code(\"getuniform\"))}\n; This performs the same function as UnityEngine.Random.value. Although the number returned\n; is a double because of TPT2 type limitations, it only has single-precision values.\n; If you need to do math that accurately mimics single-precision game math, keep that in\n; mind (you may need to use the vector type to keep the behavior consistent.)\n\n; This simulates the same behavior as the rnd() function.\n#rng_getrange(min, max) {lua(return rng_code(\"getrange\",[[{min}]],[[{max}]]))}\n; The range is inclusive. Just like with {rng_getint}, {rng_next} needs to be called\n; before this is valid.\n\n; ==========================================================================================\n; ================================= IMPLEMENTATION DETAILS =================================\n; ==========================================================================================\n\n; Change this to \"global\" for debugging\n#rng_local local\n\n\n; The 128-bit state of the rng, stored as 4 stringified ints in 44 characters.\n; With the introduction of the \"xor\" and \"and\" bitwise operations, it is best to compute this\n; using native 32-bit integers. However, we need to operate on 4 of them at once, which\n; means packing them in a string.\n; The format is ll characters per number, just enough to hold \"-2147483648\", with smaller\n; numbers being space-padded on the right. Using xorshift parlance, x[3]=t is the first\n; number and x[0]=s is the last.\n; This is used by {rng_next} to compute the next state, and {rng_getint} to convert to a number.\n; You can copy this elsewhere and restore it later if you want to simulate multiple rng seeds at once.\n:{rng_local} string rng_state\n\n\n; The structure of the code is broken up into multiple Lua functions, to allow regular\n; comments to explain them at the top of each. Lua functions are used to construct the code,\n; instead of regular macros, so that we could define our user-visible macros such as\n; {rng_init()}, {rng_next} etc. at the top without having to give the full implementation;\n; instead, a stub implementation was given and then the function is re-implemented at the\n; bottom of the file here. This allows us to use the macros freely in comments, since macros\n; are always expanded, where otherwise we could not comment on them before they were defined.\n; As a side benefit, before the full definition takes effect they will expand to nothing,\n; which is very fast to evaluate.\n\n; This constructs the code for the rng_init macro.\n; At a high level, {rng_init()} is a local.string.set and a goto.\n;\n; Setting the state is relatively straightforward: A value from rnd() is just converted to\n; a string and padded. We can easily do this 4 times in one expression.\n;\n; There is an additional quirk where if the value is exactly 0, it indicates a condition\n; where we have to restart the process. This is because the nature of rnd() is that it adds\n; one to range_max, so there is a hole where both 0 and 2^32-1 map to the same value and\n; we cannot distinguish them. Since this is very rare, we just restart in this case and roll\n; again. This is the purpose of the second line.\n{lua(function rng_codeCacheSetInit(cache)\n  cache.init = [[\nrng_reinit:\nrng_state =\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11) .\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11) .\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11) .\\\n  sub((rnd(-2147483648, 2147483646) %^ -2147483648) . \"          \", 0, 11)\ngoto(\\\n  if(contains(rng_state, \"0          \"), rng_reinit, EXTERNAL_LABEL)\\\n)\\\n]]\nend\n)}\n\n; Construct the {rng_getint} code. This is simply the last number in the state.\n;\n; Internally, getint() and getdouble() are functions so that we can use them in the\n; implementation of rng_next. The pos will always be either 33 or 0 to select either s or t.\n;\n; {rng_getuniform} has a bit more to it, but also only uses 23 bits from rng_state.\n; We use the vector type, which is a pair of single-precision numbers, to get accurate\n; single-precision rounding for the calculation to mirror what Unity does.\n{lua(function rng_codeCacheSetGetInt(cache)\n  cache.getint = function(pos)\n    return string.format(\"s2i(sub(rng_state, %s, 11), 0)\", pos)\n  end\n  cache.getdouble = function(pos)\n    return \"(i2d(\" .. cache.getint(pos) .. \" %^ -2147483648) + 2147483648.)\"\n  end\n  cache.getuniform = \"x(vec(i2d(\" .. cache.getint(33) .. \" %& 8388607), 0.) * vec(1.192093e-7, 0.))\"\nend\n)}\n\n; Construct {rng_next}.\n; This is simply Margsaglia's xorshift128, modified to deal with the fact\n; that we're using a single 128-bit string and doing all the work in parallel.\n; Bear in mind that the number indexing is \"reversed,\" i.e. x[3] is rng_state[0..11].\n; In pseudocode, xorshift128 is:\n; x[3]..x[2]..x[1]..x[0] = rng_state\n; s = x[0]\n; t = x[3]\n; t ^= t << 11\n; t ^= t >> 8\n; s ^= s >> 19\n; rng_state = x[2]..x[1]..x[0].. t ^ s\n;\n; To do this simultaneuosly and in parallel, we want to compute:\n; rng_state = rng_state[11..44] .. (\n;   x[0] ^ (x[0] >> 19)                      ; s ^ (s >> 19)\n; ^ x[3] ^ (x[3] << 11)                      ; t ^ (t << 11)\n; ^ ((x[3] >> 8) ^ (x[3] << 3)) & 0xffffff   ; (t ^ (t << 11)) >> 8\n; )\n; Left-shifts can be accomplished by multiplying by a constant. Right-shifts are trickier:\n; We can divide by a power of two, but negative values will copy the sign bit and round\n; to zero, messing everything up. Instead, we use getdouble to operate on an unsigned\n; version, and floor the result.\n{lua(function rng_codeCacheSetNext(cache)\n  cache[\"next\"] = \"rng_state = sub(rng_state, 11, 33) . sub(\" ..\n  cache.getint(33) .. \" %^ d2i(floor(\" ..\n  cache.getdouble(33) .. \" / 524288.)) %^ \" ..\n  cache.getint(0) .. \" %^ \" ..\n  cache.getint(0) .. \" * 2048 %^ d2i(floor(\" ..\n  cache.getdouble(0) .. \" / 256.)) %^ (\" ..\n  cache.getint(0) .. ' * 8) %& 16777215 . \"          \", 0, 11)'\nend\n)}\n\n{lua(function rng_getrange(min, max)\n  local nmin = tonumber(min)\n  local nmax = tonumber(max)\n  local range\n  if nmin and nmax then\n    range = string.format(\"%.1f\", nmax + 0.0 - nmin + 1)\n  else\n    range = string.format([[(i2d(%s) - i2d(%s) + 1.)]], max, min)\n  end\n  local modpart = string.format([[%s %% %s]], rng_codecache.getdouble(33), range)\n  if nmin then\n    if nmin == 0 then\n      return \"d2i(\" .. modpart .. \")\"\n    end\n    return string.format(\"d2i(%.1f + %s)\", nmin, modpart)\n  end\n  return string.format(\"d2i(i2d(%s) + %s)\", min, modpart)\nend\n)}\n\n; Return the appropriate code (macro body) given the passed in \"id\". All this does is lookup\n; the precomputed code and return that; if the code hasn't been computed yet, it calls the\n; helper functions tha exist specifically to set that up.\n; The one wrinkle is that the 3rd init macro has a parameter, and that is substituted in\n; to the cached code here.\n{lua(function rng_code(id, label, arg2)\n  if not rng_codecache then\n    rng_codecache = {}\n    rng_codeCacheSetInit(rng_codecache)\n    rng_codeCacheSetGetInt(rng_codecache)\n    rng_codeCacheSetNext(rng_codecache)\n  end\n  if id == \"getrange\" then\n    return rng_getrange(label, arg2)\n  end\n  if id == \"getint\" or id == \"getdouble\" then\n    return rng_codecache[id](33)\n  end\n  local res = rng_codecache[id]\n  if label then\n    return res:gsub(\"EXTERNAL_LABEL\", label)\n  end\n  return res\nend\n)}\n"],["rng_tester","key.t()\n\n:import rnglib\n:budget_cap max\n\n:global int predicted_rng\n:global int actual_rng\n:global int correct\n:global int wrong\n\n:local int i\n:local string which\n\ncorrect = 0\nwrong = 0\n\n{rng_init(guess)}\n\nguess:\n{rng_next}\npredicted_rng = {rng_getrange(0, 999999)}\nactual_rng = rnd(0, 999999)\nwhich = if(predicted_rng == actual_rng, \"correct\", \"wrong\")\ngis(which, 1 + gig(which))\ni += 1\ngotoif(guess, i < 10000)\n"],["D0S.RakStak","wakeup()\ngame.newround()\n\nisTowerTesting()\n\n:import rnglib\n:budget_cap max\n\n:local int rak_count\n:local double waveCount\n:global string rak_status\n\ngotoif(exit, contains(rak_status, \"running\"))\nrak_status = \"0;running\"\ngoto(if(\\\n  active.index(\"spell.raksCurse\") == 0,\\\n  end,\\\n  wait_for_rak\\\n))\n\ndo_rak:\nuseinstant(active.index(\"spell.raksCurse\"))\n; Don't increment if we didn't have mana\nrak_count += if(cooldown(active.index(\"spell.raksCurse\")) > 0., 1, 0)\nrak_status = rak_count . \";running\"\n\n#rawWaves (infinity() * 1e11 + era()) * 1e11 + wave()\nwait_for_rak:\nwaveCount = {rawWaves}\nwaitframe()\n; Abort if we exited or restarted or are finished with stacks\ngoto(if(\\\n  health(false) == 0. || {rawWaves} < waveCount || contains(rak_status, \"5\"),\\\n  end,\\\n  if(\\\n    cooldown(active.index(\"spell.raksCurse\")) == 0.,\\\n    rng_reinit,\\\n    wait_for_rak\\\n  )\\\n))\n\n{rng_init(guess)}\n\nguess:\n{rng_next}\ngoto(if(\\\n  {rng_getrange(0, 999)} == 0,\\\n  do_rak,\\\n  guess + rnd(0, 0)\\\n))\\\n\nend:\nrak_status = sub(rak_status, 0, 1)\nexit:\n"],["rng_testuniform","key.t()\n\n:import rnglib\n:budget_cap max\n\n:global double predicted_rng\n:global double actual_rng\n:global int correct\n:global int wrong\n\n:local int i\n:local string which\n\ncorrect = 0\nwrong = 0\n\n{rng_init(guess)}\n\nguess:\n{rng_next}\npredicted_rng = {rng_getuniform}\nactual_rng = rnd(0., 1.)\nwhich = if(predicted_rng == actual_rng, \"correct\", \"wrong\")\ngis(which, 1 + gig(which))\ni += 1\ngotoif(guess, i < 10000)\n"]]}}
```
