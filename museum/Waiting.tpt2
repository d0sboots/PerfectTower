:import museum5_macros
:name {script(Waiting)}

:budget_cap max

:global int state_____
:global int buyTier___
:global int budgetTier
:global int numLoops__
:global int targetTier
:global int numUpgTier

:global string museum_status
:global string combineSlots

; Cubes needed to upgrade to budgetTier. Temporary variable, can be made global
; for debugging.
:local double neededCubes

; Time of next budget calc. Used to avoid recalculating budget too often.
:local double nextBudget

:local int i

; Construct the jump table for the goto below.
; Because of the one-pass nature of the editor, we can't make this work with labels
; directly - they won't fold into the expressions. Instead, we define the targets
; with macros and have a "debug assert" that is enabled as part of the museum status.
#j_ui 02
#j_se 16
#j_cm 30
#jumptable {j_ui}{j_se}{j_cm}{j_ui}{j_ui}
#labels_jump (0 . ui_loop . setup_combine . start_combine . 0 . ui_loop . 0 . ui_loop)

; Master dispatch goto. This is our first line because our script wears many hats, and
; we want to decide what we're doing immediately. Also, for the combiner to be effecient
; we want to execute as little extra cruft as possible (it will run millions of times).
; So, we optimize our ternaries on the assumption that we are combining, first.
goto(if(\
  contains(impulse(), "Waiting"),\
  loop_inc,\
  if(\
    {in_error},\
    ui_loop,\
    s2i(sub("{jumptable}", state_____, 2), 99)\
  )\
))

ui_loop:
; We want this script to be the only running one while we wait.
; This line is duplicated with start_combine, but it's not worth trying to merge them.
stop("{script(Combining)}")

budget_start:
; Looping through all the slots and doing the explicit budget tier calculation is
; slow. Thus, we do an approximation here that is an intentional underestimate, and
; then let the loop refine it.
; Assumptions:
; * All 135 slots are filled with universal stones (the most expensive)
; * We get no credit for existing stones (they're all too low to count)
; (See below for where the initial formula comes from)
; neededCubes = 135. * 3. ^ numUpgTier * 18. ^ (budgetTier - 1 - numUpgTier) * 20000.
; neededCubes = 135. * 20000. * 18. ^ (budgetTier - 1) / 6. ^ numUpgTier
; 6. ^ numUpgTier * neededCubes / (135. * 20000.) = 18. ^ (budgetTier - 1)
; budgetTier = log(6 ^ numUpgTier * neededCubes / (135. * 20000.), 18.) + 1
; budgetTier = neededCubes // 18. - (135. * 20000.) // 18. + numUpgTier * (6. // 18.) + 1
; Replace "neededCubes" with "resources" and floor the result.
; Subtract 2 because we'll be adding one in the next line, and because the convention
; for budgetTier within the calculation below is to be one less.
budgetTier = max(0, d2i(floor(resource("museum.resources") // 18. - ((135. * 20000.) // 18. + 1.) + i2d(numUpgTier) * (6. // 18.))))

budget_outer_loop:
budgetTier += 1

; Determine budgetTier based on a neededCubes calculation.
;
; The user does not explicitly set the tier they want to combine to, nor do they set a
; "budget" like past scripts. Instead, they set numUpgTier, which says how many +tiers
; we will combine, and this combined with the current number of cubes (which can now be
; read) determines the final budgetTier.
;
; To determine this, we answer the following question: If we *could* buy stones at
; tier (budgetTier - numUpgTier) and upgrade them to tier budgetTier (i.e., we assume that
; they will be available at the needed tier in the offshore market), how much would it
; cost to do so? We keep incrementing budgetTier until this cost becomes more than our
; current resources, and then take the previous value, which worked.
;
; To calculate the cost, we go over every slot. Wrinkles in the calculation:
; * If (budgetTier + numUpgTier < 1), we clamp it to 1 and we'll end up upgrading less
;   that the full numUpgTier levels.
; * If the clamped value is 1, we buy (cheaper) stones from the market instead of the
;   offshore market. (Market costs 1000 vs 2000 base cost from offshore).
; * For efficiency reasons, budgetTier is actually budgetTier - 1 at this point.
;   We want that value because when calculating powers to get the price of stones,
;   the costs start at T1 but the power needs to start at 0. Because of this,
;   the loop check is offset by one and we have to fix the value after the loop.
; * Universal stones cost 10x more.
; * We use the value of the existing stone to offset the cost, since we will be using
;   the pre-existing stone to help pay for and speed up the combining.

budget_inner_loop:
; Explanation of specific terms in this equation:
; The first term is the cost savings from a pre-existing stone, which scales
;   with 3^x, but negatively. It is multiplied by 3 to avoid a correction factor
;   of 1 to budgetTier; this is cancelled in the next term.
; The last term is an if-chain to get the base cost of the gems.
; There is an odd factor of 1/3 that has been redistributed to avoid adding
; one to budgetTier, instead absorbing it into constants.
neededCubes = if(i == 0, 0., neededCubes) +\
  max(0.0, 3.0 - 3. ^ i2d(tier("loadout", i) - budgetTier)) *\
  if(\
    contains(element("loadout", i), "universal"),\
    20000. / 3.,\
    if(\
      tier("loadout", i) < 0,\
      0.,\
      if(\
        numUpgTier >= budgetTier,\
        1000. / 3.,\
        2000. / 3.\
      )\
    )\
  )
; The loadout grid is 15x9 = 135
i = (i + 1) % 135
; Multi-condition loop. Because ifs early-out, most of the expensive condtions
; here aren't evaluated for the common case, which is just doing the next iteration.
;
; The first special case is if neededCubes is 0. This happens iff the grid is
; empty, and we let budget_adjust set the tier to 0 in this case. It prevents us
; from having to iterate through a lot of levels, reducing FPS.
;
; The comparison against neededCubes is multiplied by the number of stones we'll
; be buying, which scales with 3^x, and the tier of stones we're buying, which
; scales with 18x. These terms doesn't depend on i, so we can
; factor them out here and only evaluate them once.
;
; If we successfully reach T50, we can exit without testing the next tier.
; Since budget_tier = 49 for that case, we must adjust it up. Otherwise, if
; we fail due to budget then it is already set correctly.
goto(if(\
  i != 0,\
  budget_inner_loop,\
  if(\
    neededCubes <= 0.,\
    budget_adjust,\
    if(\
      (3. ^ i2d(min(numUpgTier, budgetTier))) *\
        (18. ^ i2d(max(budgetTier - numUpgTier, 0))) * neededCubes >\
        resource("museum.resources"),\
      budget_done,\
      if(\
        budgetTier >= 49,\
        budget_adjust,\
        budget_outer_loop\
      )\
    )\
  )\
))

budget_adjust:
budgetTier = if(neededCubes <= 0., 0, budgetTier + 1)

budget_done:
; Update the budget every 200ms
nextBudget = now() + 2000000.

ui_set:
{set_status([REST])}
; From observation, stones spawn in the market in the range
; [preferredTier - 10, preferredTier] inclusive (11 tiers total), uniformly.
; We will never use a powerstone *higher* than what is needed to get to budgetTier,
; so we set the preferredTier accordingly.
museum.setPreferredTier(max(1, budgetTier - numUpgTier))
waitframe()

; We refresh the UI every frame to display the timer as it changes. (When the
; museum is boosted, it can change very rapidly.) However, recalculating the budget
; is expensive, and usually it won't change. (Aside from the user changing tiers,
; which is handled by killing and restarting this script, it only happens from
; resource changes, which would be from producers or manual conversion.)
; So, we only recalculate it at 5FPS.
goto(if(\
  isopen("museum"),\
  if(\
    now() < nextBudget,\
    ui_set,\
    budget_start\
  ),\
  close_ui\
))

close_ui:
museum_status = "</size>"
goto(99)

; Set to global for debugging of these expressions
#offscope local
; The first two letters are enough to uniquely identify every element
#offvar ("offer_" . sub(museum.slotElement(i), 0, 2))

setup_combine:
; Initialize the offers. Most elements are always available at tier 1 from the
; market, but universal *must* be bought from offshore.
; Because these loops are small (10 elements) and the next loops are bigger,
; we don't store the tier of the market offer but instead the tier that we will
; be able to combine to *using* this offer; this is +numUpgTier from the first
; value.
;
; We could potentially fold this into the next expression with careful arranging,
; but that would rely on the automatic 0-initialization of local variables. Since
; we want to be able to switch to globals for debugging, we spend the extra lines
; to initialize explicitly.
{offscope}.int.set(\
  "offer_" . sub("lielfidanaaiwaeaun", i, 2),\
  if(i == 16, -99, min(budgetTier, 1 + numUpgTier))\
)
i = (i + 2) % 18
gotoif(setup_combine, i != 0)

offshore_loop:
; Loop over all the offshore market offers to find the limiting offer to use for
; each element. We can't exceed budgetTier. If we hit a slot with
; no offer, we will harmlessly set the variable "offer_", so the rest of the
; expression does not matter.
{offscope}.int.set(\
  {offvar},\
  max(\
    {offscope}.int.get({offvar}),\
    if(museum.slotTier(i) + numUpgTier > budgetTier, -99, museum.slotTier(i) + numUpgTier)\
  )\
)
i = (i + 1) % 10
gotoif(offshore_loop, i != 0)

; Bucket-sort: We traverse the loadout once, looking for eligible slots, and
; add them to one of 9 different lists based on element. Then we combine those
; lists together at the end so that each element is grouped together. Grouping
; by element lets us reuse gems that remain in the inventory across combines,
; and precalculating the slots saves us time and effort during the combine, as
; well as making it easy to compute a (reasonably) accurate completion percentage.
#slotvar(x) ({x} . sub(element("loadout", i), 0, 2))
calculate_slots:
; In the comparison here, we don't need to worry about the case where the tier
; is -1 because that will also return "" for the element, and thus get appended
; to the garbage variable "slots_".
local.string.set({slotvar("slots_")},\
  local.string.get({slotvar("slots_")}) . if(\
    tier("loadout", i) >= {offscope}.int.get({slotvar("offer_")}),\
    "",\
    sub(i . "   ", 0, 4)\
  )\
)
i = (i + 1) % 135
gotoif(calculate_slots, i != 0)

combineSlots = ""
combine_slots:
combineSlots .= local.string.get("slots_" . sub("lielfidanaaiwaeaun", i, 2))
i = (i + 2) % 18
gotoif(combine_slots, i != 0)

goto(99)

start_combine:
; We kill our parent to avoid copies of it piling up. This takes budget, so we usually don't
; do it.
stop("{script(Combining)}")

loop_inc:
numLoops__ += 1

; This is an incredibly simple unrolled buy-combine loop.
; I tested other things, such as a loop that dynamically combines as long as there are still
; buyTier___ stones left to combine, but this performs (much) better: combine() is cheap enough
; that the overhead from the goto and logic inside that is significant.
; With 6 combines, some of them end up occaisonally wasted when doing +14 levels. But it is counterbalanced
; by the speed gain from doing less buys/gotos the rest of the time. Overall, 4/5/6 combines performed
; similarly for +14 levels, but more combines is faster at +13 and below.
;
; The order is inverted from the "natural" order of having the buy first to allow for an
; important check later on. Because this runs back-to-back so many times, it doesn't
; actually make a difference in efficiency which comes first.
combine:
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.buyTier({buy_elem}, buyTier___, 30)  ; Last is how many, always hardcoded to all
; Since everything is about speed here, we don't test *anything* except the budget, which is
; hardcoded. We will run this loop a fixed number of times, and then check the more complicated
; conditions down below. This means we overshoot on buying stones by a small amount; we can
; recover some of this cost by re-using them when we're not changing elements.
gotoif(combine, budget() > 700)

; Create another copy to keep the chain going. It's *vital* that we save budget to get to this
; line, otherwise we will have a spurious framebreak and the efficiency will tank.
; If we are finished combining, or if we have spawned too many scripts, exec "Combining" to
; handle things.
;
; We leave a significant buffer in running scripts (we can spawn up to 100 copies but we are
; only doing 50). The reason for this is complicated; if the user is looking at the
; "Power Stones" tab while combining then the efficiency will suck. We have checks to alert
; them about this, however if we do a full 100 loops and the budget is 100 then by the time
; we do the check for a frame-break, we may have already have spent 1000ms+, i.e. FPS will
; be <1. This is too laggy, so we cut back a little on loops to test more often, resulting
; in *slightly* decreased efficiency overall but much less lag for this case.
; 
; We only have the absolutely necessary checks here: The loop check and the "we're done"
; check. Everything else we defer to "Combining", to be done once every 50 loops. This is
; so miniscule in occurence compared to the core combining that everything we do there is
; basically free.
finish:
execute(if(\
  numLoops__ < 50 && tier("inventory", 0) < targetTier,\
  "{script(Waiting)}",\
  "{script(Combining)}"\
))

; Also for efficiency, it's important that the combine part of the code flows directly
; into the end of the script. (So it doesn't have to do anything extra after the execute().)
