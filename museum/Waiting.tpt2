:import museum5_macros
:name {script(Waiting)}

:budget_cap max

:global int state_____
:global int buyTier___
:global int budgetTier
:global int numLoops__
:global int targetTier
:global int numUpgTier

:global string museum_status

; Cubes needed to upgrade to budgetTier. Temporary variable, can be made global
; for debugging.
:local double neededCubes

; Time of next budget calc. Used to avoid recalculating budget too often.
:local double nextBudget

:local int i

; Master dispatch goto. This is our first line because our script wears many hats, and
; we want to decide what we're doing immediately. Also, for the combiner to be effecient
; we want to execute as little extra cruft as possible (it will run millions of times).
; So, we optimize our ternaries on the assumption that we are combining, first.
goto(if(\
  contains(impulse(), "Waiting"),\
  loop_inc,\
  if(\
    {in_error},\
    ui_loop,\
    if(\
      state_____ == 2,\
      start_combine,\
      ui_loop\
    )\
  )\
))

ui_loop:
; We want this script to be the only running one while we wait.
; This line is duplicated with start_combine, but it's not worth trying to merge them.
stop("{script(Combining)}")

budget_start:
; Looping through all the slots and doing the explicit budget tier calculation is
; slow. Thus, we do an approximation here that is an intentional underestimate, and
; then let the loop refine it.
; Assumptions:
; * All 135 slots are filled with universal stones (the most expensive)
; * We get no credit for existing stones (they're all too low to count)
; (See below for where the initial formula comes from)
; neededCubes = 135. * 3. ^ numUpgTier * 18. ^ (budgetTier - 1 - numUpgTier) * 20000.
; neededCubes = 135. * 20000. * 18. ^ (budgetTier - 1) / 6. ^ numUpgTier
; 6. ^ numUpgTier * neededCubes / (135. * 20000.) = 18. ^ (budgetTier - 1)
; budgetTier = log(6 ^ numUpgTier * neededCubes / (135. * 20000.), 18.) + 1
; budgetTier = neededCubes // 18. - (135. * 20000.) // 18. + numUpgTier * (6. // 18.) + 1
; Replace "neededCubes" with "resources" and floor the result.
; Subtract 2 because we'll be adding one in the next line, and because the convention
; for budgetTier within the calculation below is to be one less.
budgetTier = max(0, d2i(floor(resource("museum.resources") // 18. - ((135. * 20000.) // 18. + 1.) + i2d(numUpgTier) * (6. // 18.))))

budget_outer_loop:
budgetTier += 1

; Determine budgetTier based on a neededCubes calculation.
;
; The user does not explicitly set the tier they want to combine to, nor do they set a
; "budget" like past scripts. Instead, they set numUpgTier, which says how many +tiers
; we will combine, and this combined with the current number of cubes (which can now be
; read) determines the final budgetTier.
;
; To determine this, we answer the following question: If we *could* buy stones at
; tier (budgetTier - numUpgTier) and upgrade them to tier budgetTier (i.e., we assume that
; they will be available at the needed tier in the offshore market), how much would it
; cost to do so? We keep incrementing budgetTier until this cost becomes more than our
; current resources, and then take the previous value, which worked.
;
; To calculate the cost, we go over every slot. Wrinkles in the calculation:
; * If (budgetTier + numUpgTier < 1), we clamp it to 1 and we'll end up upgrading less
;   that the full numUpgTier levels.
; * If the clamped value is 1, we buy (cheaper) stones from the market instead of the
;   offshore market. (Market costs 1000 vs 2000 base cost from offshore).
; * For efficiency reasons, budgetTier is actually budgetTier - 1 at this point.
;   We want that value because when calculating powers to get the price of stones,
;   the costs start at T1 but the power needs to start at 0. Because of this,
;   the loop check is offset by one and we have to fix the value after the loop.
; * Universal stones cost 10x more.
; * We use the value of the existing stone to offset the cost, since we will be using
;   the pre-existing stone to help pay for and speed up the combining.

budget_inner_loop:
; Explanation of specific terms in this equation:
; The first term is the number of stones we'll be buying, which scales with 3^x.
; The second term is the cost savings from a pre-existing stone, which also scales
;   with 3^x, but negatively.
; The last term is an if-chain to get the base cost of the gems.
; There is an odd factor of 1/3 that has been redistributed to avoid adding
; one te budgetTier, instead absorbing it into constants.
neededCubes = if(i == 0, 0., neededCubes) +\
  (3. ^ i2d(min(numUpgTier, budgetTier))) *\
  max(0.0, 3.0 - 3. ^ i2d(tier("loadout", i) - budgetTier)) *\
  (18. ^ i2d(max(budgetTier - numUpgTier, 0))) *\
  if(\
    contains(element("loadout", i), "universal"),\
    20000. / 3.,\
    if(\
      tier("loadout", i) < 0,\
      0.,\
      if(\
        numUpgTier >= budgetTier,\
        1000. / 3.,\
        2000. / 3.\
      )\
    )\
  )
; The loadout grid is 15x9 = 135
i = (i + 1) % 135
; If we successfully reach T50, we can exit without testing the next tier.
; Since budget_tier = 49 for that case, we must adjust it up. Otherwise, if
; we fail due to budget then it is already set correctly.
goto(if(\
  i != 0,\
  budget_inner_loop,\
  if(\
    neededCubes > resource("museum.resources"),\
    budget_done,\
    if(\
      budgetTier >= 49,\
      budget_adjust,\
      budget_outer_loop\
    )\
  )\
))

budget_adjust:
budgetTier += 1

budget_done:
; Update the budget every 200ms
nextBudget = now() + 2000000.

ui_set:
{set_status([REST])}
waitframe()

; We refresh the UI every frame to display the timer as it changes. (When the
; museum is boosted, it can change very rapidly.) However, recalculating the budget
; is expensive, and usually it won't change. (Aside from the user changing tiers,
; which is handled by killing and restarting this script, it only happens from
; resource changes, which would be from producers or manual conversion.)
; So, we only recalculate it at 5FPS.
goto(if(\
  isopen("museum"),\
  if(\
    now() < nextBudget,\
    ui_set,\
    budget_start\
  ),\
  close_ui\
))

close_ui:
museum_status = "</size>"
goto(99)

start_combine:
; We kill our parent to avoid copies of it piling up. This takes budget, so we usually don't
; do it.
stop("{script(Combining)}")

loop_inc:
numLoops__ += 1

; This is an incredibly simple unrolled buy-combine loop.
; I tested other things, such as a loop that dynamically combines as long as there are still
; buyTier___ stones left to combine, but this performs (much) better: combine() is cheap enough
; that the overhead from the goto and logic inside that is significant.
; With 6 combines, some of them end up occaisonally wasted when doing +14 levels. But it is counterbalanced
; by the speed gain from doing less buys/gotos the rest of the time. Overall, 4/5/6 combines performed
; similarly for +14 levels, but more combines is faster at +13 and below.
;
; The order is inverted from the "natural" order of having the buy first to allow for an
; important check later on. Because this runs back-to-back so many times, it doesn't
; actually make a difference in efficiency which comes first.
combine:
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.combine(0)
museum.buyTier({buy_elem}, buyTier___, 30)  ; Last is how many, always hardcoded to all
; Since everything is about speed here, we don't test *anything* except the budget, which is
; hardcoded. We will run this loop a fixed number of times, and then check the more complicated
; conditions down below. This means we overshoot on buying stones by a small amount; we can
; recover some of this cost by re-using them when we're not changing elements.
gotoif(combine, budget() > 700)

; Create another copy to keep the chain going. It's *vital* that we save budget to get to this
; line, otherwise we will have a spurious framebreak and the efficiency will tank.
; If we are finished combining, or if we have spawned too many scripts, exec "Combining" to
; handle things.
;
; We leave a significant buffer in running scripts (we can spawn up to 100 copies but we are
; only doing 50). The reason for this is complicated; if the user is looking at the
; "Power Stones" tab while combining then the efficiency will suck. We have checks to alert
; them about this, however if we do a full 100 loops and the budget is 100 then by the time
; we do the check for a frame-break, we may have already have spent 1000ms+, i.e. FPS will
; be <1. This is too laggy, so we cut back a little on loops to test more often, resulting
; in *slightly* decreased efficiency overall but much less lag for this case.
; 
; We only have the absolutely necessary checks here: The loop check and the "we're done"
; check. Everything else we defer to "Combining", to be done once every 50 loops. This is
; so miniscule in occurence compared to the core combining that everything we do there is
; basically free.
finish:
execute(if(\
  numLoops__ < 50 && tier("inventory", 0) < targetTier,\
  "{script(Waiting)}",\
  "{script(Combining)}"\
))

; Also for efficiency, it's important that the combine part of the code flows directly
; into the end of the script. (So it doesn't have to do anything extra after the execute().)
