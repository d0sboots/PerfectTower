# Factory Automation Source Code

This is the source directory for the factory automation. This document explains how to make changes, as well as a change history.
To download and use the package, [go up a level](/README.md#factory-automation).

## Making changes

Modifying the code requires the enchanced editor at https://d0sboots.github.io/perfect-tower, because it makes heavy use of the `lua()` macro
to do data and code generation in Lua. It also `:import`s three files that are never part of the bundle import:
`factory_constants.tpt2`, `factory_macros.tpt2`, and `recipes.tpt2`.

The editor has a source-import feature, used the same way you import scripts.
The following will set up a new workspace for the factory:
```
{"workspaces":{"D0S.Factory":[["factory constants",":import factory macros\n\n#version v3.0.4\n\n; Everything in the list below is a valid target for automation, and can be\n; assigned to the \"target_type\" variable in \"lanuch factory craft\".\n; For example, \"make(oven, 10, \"machine.oven\")\" indicates that \"oven\" is a valid\n; item, usable from tiers 1-10, with the internal game name of \"machine.oven\"\n; (which you don't need to worry about.)\n; Thus you can enter \"oven\" in the box in the in-game editor (without the quotes).\n\n; If you add or change this list, mind this constraint:\n; * All the crafted items have to come before the rest of the items.\n; * All the item-groups must be in a single block.\n; * Prefer keeping things in alphabetical order within categories, because\n;   they are ordered the same way when presented in-game.\n\n; ===== VALID IDS =====\n\n; *** To reiterate, just use the name part (i.e. \"white_producer\"), not the whole thing! ***\n\n; ----- CRAFTED ITEMS -----\n\n; Producers, tiers 1-5\n; Special producers, tier 1 only\n{make(black_producer, 5, \"producer.statueofcubos\")}\n{make(blue_producer, 5, \"producer.workshop\")}\n{make(brown_producer, 5, \"producer.constructionFirm\")}\n{make(cyan_producer, 5, \"producer.shipyard\")}\n{make(exotic_producer, 1, \"producer.exoticgems\")}\n{make(gem_producer, 1, \"producer.gems\")}\n{make(green_producer, 5, \"producer.laboratory\")}\n{make(grey_producer, 5, \"producer.museum\")}\n{make(lightblue_producer, 5, \"producer.tradingpost\")}\n{make(orange_producer, 5, \"producer.mine\")}\n{make(pink_producer, 5, \"producer.arcade\")}\n{make(purple_producer, 5, \"producer.headquarters\")}\n{make(red_producer, 5, \"producer.factory\")}\n{make(white_producer, 5, \"producer.town\")}\n{make(yellow_producer, 5, \"producer.powerplant\")}\n\n{category(prod, white_producer, black_producer, yellow_producer)}\n\n; Machines, tiers 1-10\n{make(assembly, 10, \"machine.assembler\")}\n{make(belt, 10, \"machine.transportbelt\")}\n{make(boiler, 10, \"machine.boiler\")}\n{make(crusher, 10, \"machine.crusher\")}\n{make(cutter, 10, \"machine.cutter\")}\n{make(mixer, 10, \"machine.mixer\")}\n{make(oven, 10, \"machine.oven\")}\n{make(presser, 10, \"machine.presser\")}\n{make(refiner, 10, \"machine.refinery\")}\n{make(shaper, 10, \"machine.shaper\")}\n\n{category(mach, belt, assembly, shaper)}\n\n; Various crafted parts\n{make(block, 10, \"block\")}\n{make(chip, 5, \"chip\")}\n{make(hammer, 1, \"hammer\")}\n{make(insul_cable, 10, \"cable.insulated\")}\n{make(motor, 10, \"motor\")}\n{make(pump, 10, \"pump\")}\n{make(rubber_sapling, 1, \"sapling.rubber\")}\n{make(stacked_plate, 10, \"plate.stack\")}\n\n{category(crft, chip, block, stacked_plate)}\n\n; Transforms ore into dust, tiers 1-10\n; Because of an implementation detail, this must come before any\n; scannable items.\n; This doesn't show up in any category in the UI.\n{special(ore, 10, \"ore\")}\n\n; ----- SCANNABLE ITEM GROUPS -----\n; These are not real items, but rather groups of items that will be made together\n; if you select one of these names. They are meant for use with the Crafter, to\n; crank out sets of items to scan quickly. You will want to set the quantity to 1000.\n\n; Notes on using item groups:\n; * SCAN YOUR ORES FIRST! The factory can and will consume your ore to make stuff,\n;     and it takes a long time to get 1000 T10 ore.\n; * The quantity works a little differently than normal items. Instead of making\n;     1000 items each time, running it again will top off everything to be\n;     *at* the quantity of 1000 items.\n; * If you craft a higher tier after a lower tier, it will consume the results\n;     of the first craft to make the higher tier. Scan all the items first, before\n;     moving on to the next tier!\n; * None of these groups include Gem Producers or Exotic Producers. They are too\n;     expensive in comparison to other things, craft them on your own when you\n;     judge the time is right.\n\n; Makes *everything* (expect special producers and lumps) of the given tier.\n; This is the combination of \"chips_and_prods\", \"machines\", and \"parts\".\n; Requires x10 and high processing speed to have a hope of completing in a\n; reasonable amount of time for T5 and T10.\n; You need Quantum Warehouse to have enough space for this at higher tiers!\n{group(all, 10)}\n\n; All the tiers of chips. Warning: Expensive. Input this as tier 1.\n{group(chips, 1)}\n\n; Producers + the chip of the corresponding tier. This is everything that\n; exists in tier range 1-5, for convenience.\n{group(chip_and_prods, 5)}\n\n; All machines. Tiers 1-10\n{group(machines, 10)}\n\n; All ingredients and parts. Tiers 1-10. Doesn't include ore (scan that before\n; starting) or lumps (due to technical limitations). Lumps aren't required\n; for anything currently though.\n; Includes rubber plates at tier 1 and hammers at tier *2*.\n; Rubber trees are at tier 9 because of their ore.\n{group(parts, 10)}\n\n; All producers, except for special producers. Tiers 1-5\n{group(producers, 5)}\n\n{category(grup, all, all, producers)}\n\n; ----- INGREDIENTS AND PRODUCED PARTS -----\n\n; Parts, tiers 1-10\n{item(board, 10, \"plate.circuit\")}\n{item(cable, 10, \"cable\")}\n{item(circuit, 10, \"circuit\")}\n{item(dense_block, 10, \"block.dense\")}\n{item(dense_plate, 10, \"plate.dense\")}\n{item(ingot, 10, \"ingot\")}\n{item(pipe, 10, \"pipe\")}\n{item(plate, 10, \"plate\")}\n{item(ring, 10, \"ring\")}\n{item(rod, 10, \"rod\")}\n{item(rubber_plate, 1, \"plate.rubber\")}\n{item(screw, 10, \"screw\")}\n{item(wire, 10, \"wire\")}\n\n{category(part, circuit, board, wire)}\n\n;Tries to make dust from ores and lower-tier dusts, tiers 1-10\n; Doesn't appear in the UI\n{item(dust, 10, \"dust\")}\n\n; Tiers up dust, tiers 1-9\n; These are ore lumps, plus putting them into the mixer.\n; There is no \"only make ore lumps, without mixing them\" option right now.\n; Doesn't appear in the UI\n{special(lump, 9, \"lump\")}\n\n; Rubber, tier 1 only\n; Doesn't appear in the UI\n{item(rubber, 1, \"rubber\")}\n\n; ===== END OF VALID IDS =====\n"],["factory macros","; Infrastructure for producing all the constants in the factory package.\n; Since this is :imported, it can't produce any instructions.\n\n#script_name(name) D0S.factory {version}:{name}\n\n; Key assignments. You can edit these here, or you can edit them later in the\n; generated script (but you will have more places to modify).\n#up w\n#down s\n#left a\n#right d\n#start f\n\n; Shared hidden variables for the UI\n#action \"<size=0>fa#\"\n#status \"fs#\"\n\n; Produces the name of the queue variable for the given tier and item.\n#queue_str \"cq\"\n#queue(tier, item) -1 + 10 * ({item}) + {tier}\n\n; Raw access to the queue. Not preferred, but better than using \"queue\"\n; directly. Use for low-level optimization.\n#get_raw(raw_item) global.double.get({queue_str} . (100 + {raw_item}))\n#set_raw(raw_item, value) global.double.set({queue_str} . (100 + {raw_item}), {value})\n\n; Helper macros for operating on the craft_queue. These should be\n; used instead of direct access whenever possible.\n#get_queue(tier, item) {get_raw({queue({tier},{item})})}\n#set_queue(tier, item, value) {set_raw({queue({tier},{item})},{value})}\n\n; Add/subtract a value from the queue. Although it expands to the same thing,\n; it saves a lot of boilerplate in the source and makes it easier to understand\n; what's going on.\n#add_queue(tier, item, value) {set_queue({tier},{item},{get_queue({tier},{item})} + {value})}\n#subtract_queue(tier, item, value) {set_queue({tier},{item},{get_queue({tier},{item})} - ({value}))}\n\n; Used with factory.composite_string to extract the name from the\n; returned data.\n#get_name sub(itemdata, 0, index(itemdata, \" \", 0))\n\n; These macros can only be called *after* factory.composite_string,\n; i.e. later on in the script.\n#items_count {lua(return factory.items_count)}\n#tiers_char sub(itemdata, {lua(return factory.entry_size - 1)}, 1)\n\n{lua(\\\n  factory = {};\\\n  factory.items = {};\\\n  factory.item_names = {};\\\n  factory.categories = {};\\\n  factory.name_max_size = 0;\\\n  factory.game_name_sizes = {};\\\n  factory.game_name_sizes.item = 0;\\\n  factory.game_name_sizes.craft = 0;\\\n  factory.game_name_sizes.group = 0;\\\n  factory.game_name_sizes.special = 0;\\\n  factory.group_map = {};\\\n  factory.group_map.item = 0;\\\n  factory.group_map.craft = 1;\\\n  factory.group_map.group = 2;\\\n  factory.group_map.special = 2; --[[Intentionally the same]]\\\n\\\n  function factory.add_item(name, tiers, game_name, craft_type)\\\n    local item = {};\\\n    item.id = #factory.items + 1;\\\n    if item.id > 89 then\\\n      return \"Too many items: Over the limit while adding \" .. name;\\\n    end\\\n    item.name = name;\\\n    item.game_name = game_name;\\\n    item.tier = tiers;\\\n    item.craft_type = craft_type;\\\n    factory.items[item.id] = item;\\\n    factory.item_names[name] = item;\\\n    if #name > factory.name_max_size then\\\n      factory.name_max_size = #name;\\\n    end\\\n    if #game_name > factory.game_name_sizes[craft_type] then\\\n      factory.game_name_sizes[craft_type] = #game_name;\\\n    end\\\n    return \":const int \" .. name .. \" \" .. #factory.items;\\\n  end\\\n\\\n  function factory.composite_string(var, filter, use_group_info)\\\n    local acc = {};\\\n    local size = 0;\\\n    local first = #factory.items;\\\n    local last = 0;\\\n    local group_map = factory.group_map;\\\n    \\\n    if filter == nil then\\\n      size = math.max(factory.game_name_sizes[\"item\"], factory.game_name_sizes[\"craft\"]);\\\n    else\\\n      size = factory.game_name_sizes[filter];\\\n    end\\\n    size = size + 1;\\\n    local fmt = \"%-\" .. size .. \"s%d\";\\\n    size = size + 1;\\\n    acc[1] = 'sub(\"';\\\n    for i = 1, #factory.items do\\\n      local item = factory.items[i];\\\n      if filter == nil or item.craft_type == filter then\\\n        if use_group_info then\\\n          acc[#acc + 1] = string.format(fmt, item.game_name, group_map[item.craft_type]);\\\n        else\\\n          acc[#acc + 1] = string.format(fmt, item.game_name, item.tier - 1);\\\n        end\\\n        if i < first then first = i end\\\n        if i > last then last = i end\\\n      end\\\n    end\\\n    acc[#acc + 1] = '\", ' .. size .. \" * (\" .. var .. \"), \" .. size .. ')';\\\n    factory.items_count = last - first + 1;\\\n    factory.entry_size = size;\\\n    return table.concat(acc);\\\n  end\\\n\\\n  function factory.add_category(name, ...)\\\n    local category = {}\\\n    factory.categories[#factory.categories + 1] = category\\\n    category.name = name\\\n    local name1, name2, name3 = \"default\", \"first\", \"last\"\\\n    local arg1, arg2, arg3 = ...\\\n    for i = 1, 3 do\\\n      local trimmed = arg1:gsub(\"^ +\", \"\")\\\n      local item = factory.item_names[trimmed]\\\n      if not item then\\\n        return \"Can't find \" .. trimmed\\\n      end\\\n      category[name1] = item.id\\\n      name1, name2, name3 = name2, name3\\\n      arg1, arg2, arg3 = arg2, arg3\\\n    end\\\n  end\\\n)}\n\n; Define a new production item with name \"name\", craftable from tiers 1-\"tiers\".\n; The string passed to produce() is \"game_name\".\n; It will take the next available id, starting from 1.\n#item(name, tiers, game_name) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, {game_name}, \"item\")\\\n)}\n\n; Define a new production item with name \"name\", craftable from tiers 1-\"tiers\".\n; The string passed to craft() is \"game_name\".\n; It will take the next available id, starting from 1.\n#make(name, tiers, game_name) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, {game_name}, \"craft\")\\\n)}\n\n; Define a new item group, i.e. a set of items designed to be scanned in the\n; crafter. Because items need a valid game_name to be passed to count() in\n; various places (or else there will be spurious logging), we use \"ore\".\n; (The value returned from count() will always be ignored.)\n#group(name, tiers) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, \"ore\", \"group\")\\\n)}\n\n; Defines a \"special\" item. This has a real name, like an item, but acts\n; like an item-group in other ways. This is used for lumps and ore, which\n; require special-case handling.\n#special(name, tiers, game_name) {lua(\\\n  return factory.add_item(\"{name}\", {tiers}, {game_name}, \"special\")\\\n)}\n\n; Defines a category grouping for the UI. \"First\" and \"last\" are the span of\n; the group (inclusive), in item names. Must be called *after* the relevant items\n; are defined.\n#category(name, default, first, last) {lua(\\\n  return factory.add_category(\"{name}\", \"{default}\", \"{first}\", \"{last}\")\\\n)}\n"],["worker_storage_lib","; This library will find a slot in the pool of workers to use as \"permanent storage\".\n; If one doesn't already exist with the given tag, a new one will be allocated,\n; *but* it will avoid overwriting other worker names using the same sytem of tags\n; for storage. Thus, scripts can use this to cooperate without having to\n; explicitly assign worker slot numbers.\n;\n; The scheme is that a name will be prefixed with \"[TOKEN]\", where \"TOKEN\" is\n; some short, unique word that will identify the script in question. For instance,\n; the factory might use the word \"factory\".\n;\n; This library does not actually store anything in the worker name. Instead, it\n; sets the variable \"worker_slot\", which you must declare in your code.\n; If worker_slot < 100, then it found a valid slot with the worker_prefix.\n; If 100 <= worker_slot < 200, then there was no existing slot, but new data\n; can be initialized at (worker_slot - 100). If worker_slot == 200, then there\n; are no available slots at all, and you should show an error message or take\n; approriate action.\n;\n; A complete example looks like this (replace angle brackets with curlies):\n;\n; :local int worker_slot\n; <worker_lib_line_1([TOKEN])>\n; <worker_lib_line_2>\n\n; =================================================================================\n\n#worker_prefix {lua(return worker_lib_prefix)}\n#worker_lacks_prefix sub(worker.name(worker_slot), 0, {len({worker_prefix})}) != \"{worker_prefix}\"\n\n; The first macro, which defines the first line and the loop variable that we\n; jump to. We also store the worker_prefix with Lua, so that we don't need to\n; repeat it on the 2nd macro.\n; We don't want to skip slot 0. Doing it like this saves a line.\n#worker_lib_line_1(worker_prefix_arg) {lua(\\\n  worker_lib_prefix = \"{worker_prefix_arg}\"\\\n)}\\\nfind_worker_slot_loop: worker_slot = worker_slot + if({worker_lacks_prefix}, 1, 0)\n\n; The second macro, which iterates until we're done.\n; The test against worker.group() checks for non-existant workers. They would\n; otherwise show as acceptable candidates, and we need to keep iterating to 200\n; in that case.\n#worker_lib_line_2 gotoif(find_worker_slot_loop,\\\n  worker_slot < 100 && {worker_lacks_prefix} ||\\\n  worker_slot >= 100 && worker_slot < 200 && (worker.group(worker_slot - 100) == -1 || contains(sub(worker.name(worker_slot - 100), 0, 1), \"[\")))\n"],["recipes",":import factory constants\n\n{lua(\\\n  factory.recipes = {};\\\n)}\n\n; Infrastructure for defining the recipe list.\n{lua(\\\n  function factory.recipe(item)\\\n    local recipe_item = factory.item_names[item];\\\n    if not recipe_item then\\\n      return \"Unknown item '\" .. item .. \"'\";\\\n    end\\\n    factory.recipe_item = recipe_item;\\\n    local offset = 10 * recipe_item.id;\\\n    --[[There are two types of recipe list that we store: A \"forward\" list stored\\\n        on the item itself, which records what items are needed to *make* that\\\n        item, and a \"reverse\" list stored on the main factory object and indexed\\\n        by queue id, which records what items can be *made from* the item.\\\n        The forward list is used by the item group system, while the reverse list\\\n        is used by the recipe system proper.]]\\\n    for i = offset, offset + recipe_item.tier - 1 do\\\n      if not factory.recipes[i] then\\\n        factory.recipes[i] = {};\\\n      end\\\n    end\\\n    recipe_item.recipes = {};\\\n    for i = 1, recipe_item.tier do\\\n      recipe_item.recipes[i] = {};\\\n    end\\\n  end\\\n\\\n  function factory.component(tiers, item_name, counts)\\\n    local recipe_item = factory.recipe_item;\\\n    local item_name = item_name:gsub(\" \", \"\");\\\n    local item = factory.item_names[item_name];\\\n    if not item then\\\n      return \"Unknown item '\" .. item_name .. \"'\";\\\n    end\\\n    if item.craft_type == \"group\" then\\\n      return string.format(\\\n        [[Cannot add item \"%s\" because it is a group]],\\\n        item.name,\\\n        recipe_item.name,\\\n        recipe_item.craft_type\\\n      );\\\n    end\\\n    local tier_tmp = {};\\\n    for word in tiers:gmatch(\"%S+\") do\\\n      local tier = tonumber(word);\\\n      if not tier then\\\n        return \"Bad tier \" .. word\\\n      end\\\n      tier_tmp[#tier_tmp + 1] = tier;\\\n    end\\\n    if #tier_tmp ~= 1 and #tier_tmp ~= recipe_item.tier then\\\n      return \"Tiers list has wrong size, item \" ..\\\n        recipe_item.name .. \" has \" .. recipe_item.tier .. \" tiers\";\\\n    end\\\n    \\\n    local base_tier;\\\n    for i = 1, recipe_item.tier do\\\n      base_tier = tier_tmp[i] or base_tier;\\\n      local tier = base_tier;\\\n      if tier < 1 then\\\n        tier = tier + i;\\\n      end\\\n      tier_tmp[i] = tier;\\\n    end\\\n    \\\n    local counts_tmp = {};\\\n    for word in counts:gmatch(\"%S+\") do\\\n      local count = tonumber(word);\\\n      if not count then\\\n        return \"Bad count \" .. word\\\n      end\\\n      counts_tmp[#counts_tmp + 1] = count;\\\n    end\\\n    if #counts_tmp ~= 1 and #counts_tmp ~= recipe_item.tier then\\\n      return \"Counts list has wrong size, item \" ..\\\n        recipe_item.name .. \" has \" .. recipe_item.tier .. \" tiers\";\\\n    end\\\n    for i = #counts_tmp + 1, recipe_item.tier do\\\n      counts_tmp[i] = counts_tmp[i-1];\\\n    end\\\n    --[[Finally, merge the two expanded lists and distribute the results\\\n        across the recipes for each tier. These recipes are \"reversed,\"\\\n        in the sense that they don't describe how to make each item, but\\\n        rather all the items that this one can be used to help make.\\\n        It's this reversed list that is needed for computing the material\\\n        needs when crafting.]]\\\n    local recipes = factory.recipes;\\\n    local offset = recipe_item.id * 10 - 1;\\\n    for i = 1, recipe_item.tier do\\\n      local tier = tier_tmp[i];\\\n      local count = counts_tmp[i];\\\n      if count > 0 and tier > 0 then\\\n        --[[Tiers less than 1 can happen naturally, due to the negative tier\\\n            convention, so they are silently dropped. Tiers greater than the\\\n            the maximum number of tiers are an error.]]\\\n        if tier > item.tier then\\\n          return \"Tier \" .. tier .. \" > item max tier \" .. item.tier;\\\n        end\\\n        local idx = item.id * 10 + tier - 1;\\\n        local comp = recipes[idx];\\\n        if comp == nil then\\\n          comp = {};\\\n          recipes[idx] = comp;\\\n        end\\\n        comp[#comp + 1] = offset + i;\\\n        comp[#comp + 1] = count;\\\n        local item_recipe = recipe_item.recipes[i];\\\n        item_recipe[#item_recipe + 1] = idx;\\\n        item_recipe[#item_recipe + 1] = count;\\\n      end\\\n    end\\\n  end\\\n)}\n\n; Every recipe begins with this line. There must be one (and only one)\n; recipe declaration for each item, even if there is no way to make it\n; (like for rubber).\n#recipe(item) {lua(return factory.recipe([[{item}]]))}\n\n; After starting a recipe, list its components with this. A component\n; declares a single item that is used, and the the tiers and counts of that\n; item for each tier of the recipe_item that's being made.\n; The list on the left side is the tiers, the list on the right is the counts.\n;\n; For instance:\n;  recipe(white_producer)\n;  component(2 3 5 7 9, screw, 2 4 4 4 4)\n; Means that a T1 white_producer needs 2 T2 screws, a T2 white_producer needs\n; 4 T3 screws, T3 requires 4 T5 screws, etc.\n; \n; There are additional space-saving wrinkles. Instead of repeating a number\n; for every tier or every count when it's always the same, you can list it\n; once. This is all-or-nothing: It must be exactly once, or listed once for\n; every tier in the recipe.\n; Also, in the tier list you can use numbers less than 1. This means that\n; the position in the list will be added to the number. I.e. a value of\n; 0 becomes equal to \"current_tier\", -1 becomes \"current_tier - 1\", etc.\n#component(tiers, item, counts) {lua(\\\n  return factory.component([[{tiers}]],[[{item}]],[[{counts}]]);\\\n)}\n\n; ===== BEGIN RECIPES =====\n\n{recipe(white_producer)}\n{component(2 3 5 7 9, screw, 2 4 4 4 4)}\n{component(2 0 0 0 0, plate, 2 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 2 2 2 6)}\n{component(-1, chip, 0 2 2 2 4)}\n{component(-1, white_producer, 1)}\n\n{recipe(red_producer)}\n{component(1 3 5 7 9, wire, 1 4 4 4 4)}\n{component(2 0 0 0 0, screw, 1 0 0 0 0)}\n{component(0 3 5 7 9, board, 0 1 1 1 3)}\n{component(2 3 5 0 0, plate, 2 2 2 0 0)}\n{component(0 0 0 7 9, dense_plate, 0 0 0 2 4)}\n{component(1 1 2 3 4, chip, 2 1 1 1 3)}\n{component(-1, red_producer, 1)}\n\n{recipe(orange_producer)}\n{component(2 3 5 7 9, screw, 2 2 2 4 4)}\n{component(1 2 4 6 8, wire, 2 3 2 5 5)}\n{component(2 0 5 7 9, plate, 1 0 1 2 2)}\n{component(0 3 5 7 9, dense_plate, 0 2 2 2 2)}\n{component(1 1 2 3 4, chip, 1)}\n{component(-1, orange_producer, 1)}\n\n{recipe(blue_producer)}\n{component(0 2 4 6 8, wire, 0 4 2 8 8)}\n{component(1 3 5 7 9, wire, 4 2 2 2 2)}\n{component(2 3 5 7 9, plate, 1 2 2 2 2)}\n{component(1 0 2 3 4, chip, 1 0 2 2 2)}\n{component(-1, blue_producer, 1)}\n\n{recipe(brown_producer)}\n{component(2 4 6 8 10, rod, 3 4 10 10 10)}\n{component(2 4 6 8 10, plate, 2)}\n{component(1 1 2 3 4, chip, 1 2 2 2 2)}\n{component(-1, brown_producer, 1)}\n\n{recipe(green_producer)}\n{component(0 3 5 7 9, pipe, 0 3 5 10 14)}\n{component(2 4 6 8 10, motor, 1)}\n{component(1 3 5 7 9, dense_plate, 2 2 4 4 6)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, green_producer, 1)}\n\n{recipe(purple_producer)}\n{component(1 3 5 7 9, wire, 2 4 8 8 12)}\n{component(2 4 6 8 10, motor, 1 2 2 2 2)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, purple_producer, 1)}\n\n{recipe(yellow_producer)}\n{component(1 3 5 7 9, insul_cable, 2 2 4 4 6)}\n{component(2 4 6 8 10, motor, 1)}\n{component(0 3 5 7 9, block, 0 3 5 5 14)}\n{component(0, chip, 3 2 4 4 6)}\n{component(-1, yellow_producer, 1)}\n\n{recipe(pink_producer)}\n{component(2 4 6 8 9, insul_cable, 4 6 6 6 6)}\n{component(2 4 6 8 10, pipe, 4 4 4 4 8)}\n{component(0, chip, 4 4 4 4 6)}\n{component(-1, pink_producer, 1)}\n\n{recipe(lightblue_producer)}\n{component(2 4 6 8 10, ring, 6 8 8 8 12)}\n{component(2 4 6 8 10, plate, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, lightblue_producer, 1)}\n\n{recipe(cyan_producer)}\n{component(2 4 6 8 10, insul_cable, 6 8 8 8 12)}\n{component(1 3 5 7 9, block, 4)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, cyan_producer, 1)}\n\n{recipe(grey_producer)}\n{component(3 5 7 9 10, insul_cable, 6 7 7 7 9)}\n{component(2 4 6 8 10, block, 4 5 5 5 7)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, grey_producer, 1)}\n\n{recipe(black_producer)}\n{component(1 3 5 7 9, dense_block, 4 5 5 5 7)}\n{component(2 4 6 8 10, motor, 2)}\n{component(2 4 6 8 10, pipe, 2)}\n{component(2 4 6 8 10, pump, 2 3 3 3 5)}\n{component(0, chip, 2 2 2 2 4)}\n{component(-1, black_producer, 1)}\n\n{recipe(gem_producer)}\n{component(5, chip, 10)}\n{component(4, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(1, dense_block, 1)}\n{component(2, dense_block, 1)}\n{component(3, dense_block, 1)}\n{component(4, dense_block, 1)}\n{component(5, dense_block, 1)}\n{component(6, dense_block, 1)}\n{component(7, dense_block, 1)}\n{component(8, dense_block, 1)}\n{component(9, dense_block, 1)}\n{component(10, dense_block, 1)}\n\n{recipe(exotic_producer)}\n{component(5, chip, 10)}\n{component(10, insul_cable, 2)}\n{component(10, dense_block, 10)}\n{component(10, assembly, 1)}\n{component(10, boiler, 1)}\n{component(10, crusher, 1)}\n{component(10, cutter, 1)}\n{component(10, mixer, 1)}\n{component(10, oven, 1)}\n{component(10, presser, 1)}\n{component(10, refiner, 1)}\n{component(10, shaper, 1)}\n{component(10, belt, 1)}\n\n{recipe(oven)}\n{component(0, plate, 4 6 8 8 8 8 8 8 8 8)}\n{component(0, insul_cable, 2 2 3 3 3 4 4 4 4 4)}\n{component(0, block, 0 0 0 0 0 2 2 2 2 2)}\n{component(-1, oven, 1)}\n\n{recipe(presser)}\n{component(1, hammer, 2 0 0 0 0 0 0 0 0 0)}\n{component(0, plate, 4 5 7 7 7 9 9 9 9 9)}\n{component(0, wire, 1 1 2 2 2 3 3 3 3 3)}\n{component(0, block, 0 0 0 0 4 5 5 5 5 5)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 2)}\n{component(-1, presser, 1)}\n\n{recipe(assembly)}\n{component(0, pipe, 1 1 1 1 1 2 2 2 2 2)}\n{component(0, dense_plate, 6 5 8 8 8 10 10 10 12 12)}\n{component(0, motor, 1 1 1 1 1 1 1 1 2 2)}\n{component(1 1 1 2 2 2 3 3 4 4, chip, 1 1 1 1 1 1 1 1 1 2)}\n{component(-1, assembly, 1)}\n\n{recipe(refiner)}\n{component(0, block, 0 0 0 0 0 0 5 5 5 7)}\n{component(0, dense_plate, 4)}\n{component(0, motor, 1 1 1 1 2 2 2 2 2 4)}\n{component(0, ring, 1 2 2 2 3 3 3 3 3 5)}\n{component(0, pump, 1 2 2 2 3 3 3 3 3 5)}\n{component(1 1 2 2 2 2 3 4 4 5, chip, 2)}\n{component(-1, refiner, 1)}\n\n{recipe(mixer)}\n{component(0, dense_plate, 5 4 4 5 5 6 6 6 6 6)}\n{component(0, motor, 2)}\n{component(0, pump, 1 1 1 2 2 3 3 3 3 3)}\n{component(1 1 1 2 2 2 2 3 4 4, chip, 1 1 1 2 2 3 3 3 3 3)}\n{component(-1, mixer, 1)}\n\n{recipe(crusher)}\n{component(0, dense_plate, 7 8 8 8 8 8 8 9 9 9)}\n{component(0, motor, 1 1 1 1 1 1 1 2 2 2)}\n{component(1 1 1 2 2 2 2 2 4 4, chip, 1 2 2 2 2 2 2 3 3 3)}\n{component(-1, crusher, 1)}\n\n{recipe(belt)}\n{component(1, rubber, 3 4 4 4 4 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 0 0 0 4 5 5 5 5)}\n{component(0, motor, 3 3 3 3 3 3 4 4 4 4)}\n{component(0, insul_cable, 3 4 4 4 4 4 5 5 5 5)}\n{component(0 0 0 1 2 2 3 3 4 4, chip, 0 0 0 4 4 4 5 5 5 5)}\n{component(-1, belt, 1)}\n\n{recipe(cutter)}\n{component(0, plate, 2 2 2 2 2 2 2 0 0 0)}\n{component(0, dense_plate, 3 3 3 3 3 4 4 2 2 2)}\n{component(0, block, 0 0 0 0 0 0 0 4 4 6)}\n{component(0, motor, 3 4 4 4 4 5 5 5 5 7)}\n{component(-1, cutter, 1)}\n\n{recipe(shaper)}\n{component(0, plate, 4 4 4 4 4 4 4 4 4 0)}\n{component(0, dense_plate, 0 0 0 0 0 0 0 0 0 4)}\n{component(0, screw, 1 2 2 2 2 3 3 3 3 3)}\n{component(0, block, 1 2 2 2 2 3 3 3 3 0)}\n{component(0, dense_block, 0 0 0 0 0 0 0 0 0 5)}\n{component(0, motor, 2)}\n{component(0, insul_cable, 1 1 1 1 1 2 2 2 2 4)}\n{component(-1, shaper, 1)}\n\n{recipe(boiler)}\n{component(0, wire, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, dense_plate, 2 2 2 3 3 3 3 3 4 5)}\n{component(0, block, 4 7 7 8 8 8 8 8 9 10)}\n{component(0, motor, 1 1 1 2 2 2 2 2 3 4)}\n{component(0, screw, 2)}\n{component(0, pump, 1)}\n{component(-1, boiler, 1)}\n\n{recipe(chip)}\n{component(1 3 5 7 9, circuit, 2)}\n{component(2 4 6 8 10, circuit, 2 4 4 2 2)}\n{component(1 3 5 7 9, board, 1 4 4 6 8)}\n{component(2 4 6 8 10, board, 1 2 2 6 8)}\n{component(-1, chip, 0 4 8 12 12)}\n\n{recipe(insul_cable)}\n{component(0, cable, 1 1 1 2 3 4 5 10 12 16)}\n{component(1, rubber, 1 2 0 0 0 0 0 0 0 0)}\n{component(1, rubber_plate, 0 0 2 4 6 8 10 10 12 16)}\n\n{recipe(stacked_plate)}\n{component(0, plate, 9)}\n\n{recipe(motor)}\n{component(0, plate, 4)}\n{component(0, screw, 1)}\n{component(0, rod, 2)}\n{component(0, wire, 1)}\n{component(1, rubber, 1)}\n\n{recipe(pump)}\n{component(0, plate, 2)}\n{component(0, motor, 1)}\n{component(0, ring, 2)}\n{component(1, rubber_plate, 4)}\n\n{recipe(hammer)}\n{component(2, ingot, 6)}\n{component(2, rod, 1)}\n\n{recipe(block)}\n{component(0, dense_plate, 8 8 8 8 8 8 12 12 12 12)}\n\n{recipe(rubber_sapling)}\n{component(0, rubber, 8)}\n{component(9, ore, 1)}\n\n{recipe(producers)}\n#recipe_producers(x) \\\n{component(0, white_producer, {x})}\\\n{component(0, red_producer, {x})}\\\n{component(0, orange_producer, {x})}\\\n{component(0, blue_producer, {x})}\\\n{component(0, brown_producer, {x})}\\\n{component(0, green_producer, {x})}\\\n{component(0, purple_producer, {x})}\\\n{component(0, yellow_producer, {x})}\\\n{component(0, pink_producer, {x})}\\\n{component(0, lightblue_producer, {x})}\\\n{component(0, cyan_producer, {x})}\\\n{component(0, grey_producer, {x})}\\\n{component(0, black_producer, {x})}\n{recipe_producers(1)}\n\n{recipe(machines)}\n{component(0, oven, 1)}\n{component(0, presser, 1)}\n{component(0, assembly, 1)}\n{component(0, refiner, 1)}\n{component(0, mixer, 1)}\n{component(0, crusher, 1)}\n{component(0, belt, 1)}\n{component(0, cutter, 1)}\n{component(0, shaper, 1)}\n{component(0, boiler, 1)}\n\n{recipe(parts)}\n#recipe_parts \\\n{component(0, insul_cable, 1)}\\\n{component(0, stacked_plate, 1)}\\\n{component(0, motor, 1)}\\\n{component(0, pump, 1)}\\\n{component(1, hammer, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, block, 1)}\\\n{component(0, ingot, 1)}\\\n{component(0, plate, 1)}\\\n{component(0, dense_plate, 1)}\\\n{component(0, dense_block, 1)}\\\n{component(0, pipe, 1)}\\\n{component(0, cable, 1)}\\\n{component(0, wire, 1)}\\\n{component(0, rod, 1)}\\\n{component(0, ring, 1)}\\\n{component(0, screw, 1)}\\\n{component(0, board, 1)}\\\n{component(0, circuit, 1)}\\\n{component(0, rubber_plate, 1 0 0 0 0 0 0 0 0 0)}\\\n{component(1, rubber_sapling, 0 0 0 0 0 0 0 0 1 0)}\n{recipe_parts}\n\n{recipe(chips)}\n{component(1, chip, 1)}\n{component(2, chip, 1)}\n{component(3, chip, 1)}\n{component(4, chip, 1)}\n{component(5, chip, 1)}\n\n{recipe(chip_and_prods)}\n{component(0, chip, 1)}\n{recipe_producers(1)}\n\n#recipe_machines_and_parts \\\n{component(0, oven, 1)}\\\n{component(1, presser, 0 1 0 0 0 0 0 0 0 0)}\\\n{component(0, presser, 0 1 1 1 1 1 1 1 1 1)}\\\n{component(0, assembly, 1)}\\\n{component(0, refiner, 1)}\\\n{component(0, mixer, 1)}\\\n{component(0, crusher, 1)}\\\n{component(0, belt, 1)}\\\n{component(0, cutter, 1)}\\\n{component(0, shaper, 1)}\\\n{component(0, boiler, 1)}\\\n{recipe_parts}\n\n{recipe(all)}\n{component(0, chip, 1 1 1 1 1 0 0 0 0 0)}\n{recipe_producers(1 1 1 1 1 0 0 0 0 0)}\n{recipe_machines_and_parts}\n\n; Ore is a terminal, unable to be crafted.\n{recipe(ore)}\n\n; These recipes have special-case code to handle them, because of the\n; complexities involved with choosing between ore and lumps for making dust.\n{recipe(lump)}\n{recipe(dust)}\n\n{recipe(ingot)}\n{component(0, dust, 1)}\n\n{recipe(plate)}\n{component(0, ingot, 1)}\n\n{recipe(dense_plate)}\n{component(0, stacked_plate, 1)}\n\n{recipe(dense_block)}\n{component(0, block, 1)}\n\n{recipe(pipe)}\n{component(0, plate, 1)}\n\n{recipe(cable)}\n{component(0, ingot, 0.5)}\n\n{recipe(wire)}\n{component(0, cable, 1)}\n\n{recipe(rod)}\n{component(0, ingot, 0.5)}\n\n{recipe(ring)}\n{component(0, rod, 1)}\n\n{recipe(screw)}\n{component(0, rod, 0.25)}\n\n{recipe(board)}\n{component(0, plate, 1)}\n\n{recipe(circuit)}\n{component(0, cable, 1)}\n\n; Rubber is a terminal, unable to be crafted.\n{recipe(rubber)}\n\n{recipe(rubber_plate)}\n{component(0, rubber, 1)}\n\n; ===== END RECIPES =====\n"],["run_recipes",":import factory constants\n:import recipes\n\n:name {script_name(run_recipes)}\n\n; Debugging function, kept in case of future problems.\n#debug_dump_recipes {lua(\\\n  acc = {};\\\n  for i = 1, #factory.items do\\\n    local item = factory.items[i];\\\n    acc[#acc+1] = string.format(\"%02d %-18s [\", i, item.name);\\\n    for j = 1, item.tier do\\\n      if j ~= 1 then acc[#acc+1] = string.format(\"\\n%23s\", \"\") end\\\n      acc[#acc+1] = \"(\";\\\n      local recipe = factory.recipes[i * 10 + j - 1];\\\n      for k = 1, #recipe do\\\n        if k ~= 1 then acc[#acc+1] = \" \" end\\\n        acc[#acc+1] = recipe[k];\\\n      end\\\n      acc[#acc+1] = \")\";\\\n    end\\\n    acc[#acc+1] = \"]\\n\";\\\n  end\\\n  return table.concat(acc);\\\n)}\n\n;{debug_dump_recipes}\n\n; Now that all the recipes are defined, we have to put them in a valid order.\n; We do this with a modified breadth-first-search, optimized around the\n; structure of our data.\n; Each item (which in this context is a type-tier pair, identified by\n; the formula type * 10 + tier) is sequentially checked against a graph\n; that is incrementally being formed. If all its recipe-items have already been\n; satisfied (or it has none), then it is also satisfied, and (as long\n; as it has recipe-items) it's put on a queue to be output. Otherwise, a count\n; is kept of how many unsatisfied recipes it has, and an entry is made in each\n; blocking recipe pointing back to this item.\n; After each item, the queue is processed. The head of the queue is popped\n; and gets the next sequential id; this is how the recipes get their order.\n; Also, any items blocked on it will have their tallies decremented by one.\n; If these go to zero, they are now satisfied and will be added to the queue\n; to be output, as well.\n{lua(\\\n  local recipes_list = {};\\\n  factory.recipes_list = recipes_list;\\\n  local items = factory.items;\\\n  local recipes = factory.recipes;\\\n  local graph = {};\\\n  local queue = {};\\\n  for tier = 10, 1, -1 do\\\n    for item_id = 1, #items do\\\n      local item = items[item_id];\\\n      local id = 10 * item_id + tier - 1;\\\n      local recipe = recipes[id];\\\n      if not recipe then\\\n        goto continue;\\\n      end\\\n      local entry = graph[id];\\\n      if not entry then\\\n        entry = {};\\\n        entry.blocking = {};\\\n        graph[id] = entry;\\\n      end\\\n      local blockers = 0;\\\n      if recipe then\\\n        for i = 1, #recipe, 2 do\\\n          local other = graph[recipe[i]];\\\n          if not other then\\\n            other = {};\\\n            other.blocking = {};\\\n            other.blockers = -1;\\\n            graph[recipe[i]] = other;\\\n          end\\\n          if other.blockers ~= 0 then\\\n            blockers = blockers + 1;\\\n            other.blocking[#other.blocking + 1] = id;\\\n          end\\\n        end\\\n      end\\\n      entry.blockers = blockers;\\\n      \\\n      if blockers == 0 then\\\n        queue[#queue + 1] = id;\\\n      end\\\n      \\\n      local q_front = 1;\\\n      while q_front <= #queue do\\\n        id = queue[q_front];\\\n        entry = graph[id];\\\n        recipes_list[#recipes_list + 1] = id;\\\n        for i = 1, #entry.blocking do\\\n          local other = graph[entry.blocking[i]];\\\n          other.blockers = other.blockers - 1;\\\n          if other.blockers == 0 then;\\\n            queue[#queue + 1] = entry.blocking[i];\\\n          end;\\\n        end\\\n        q_front = q_front + 1\\\n      end\\\n      queue = {};\\\n      ::continue::\\\n    end\\\n  end\\\n)}\n\n; Debugging function, kept in case of future problems.\n#debug_dump_recipes_list {lua(\\\n  acc = {};\\\n  for i = 1, #factory.recipes_list do\\\n    local id = factory.recipes_list[i];\\\n    acc[#acc+1] = string.format(\"%03d:\", id);\\\n    local recipe = factory.recipes[id];\\\n    for j = 1, #recipe do\\\n      acc[#acc+1] = string.format(\" %3s\", recipe[j]);\\\n    end\\\n    acc[#acc+1] = \"\\n\";\\\n  end\\\n  return table.concat(acc);\\\n)}\n\n;{debug_dump_recipes_list}\n\n; Constructs the data table that is used to create loop_data. See below\n; for the format of this string. One difference is that in loop_data, \n; the previous item/current item index data is at the beginning and end of the\n; string. Here, that is actually only stored once, and the sub() read window is\n; expanded to overlap consequetive sections to pick up the previous item when\n; reading the next.\n#get_data(num_terms) {lua(\\\n  local num_terms = {num_terms};\\\n  local num_terms_2 = num_terms * 2;\\\n  local recipe_limit = 0;\\\n  local acc_main = {};\\\n  local sub = string.sub;\\\n  \\\n  local multipliers = \"0123a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z\";\\\n  local mult_max = {};\\\n  for i = 1, num_terms do\\\n    mult_max[i] = 0;\\\n  end\\\n  acc_main[1] = [[\"___]];\\\n  for i = 1, #factory.recipes_list do\\\n    local id = factory.recipes_list[i];\\\n    local recipe = factory.recipes[id];\\\n    local item_id = id // 10;\\\n    local limit = (#recipe - 1) // num_terms_2;\\\n    if limit < 0 then limit = 0 end;\\\n    for j = 1, (limit + 1) * num_terms_2, 2 do\\\n      acc_main[#acc_main + 1] = (j < #recipe) and recipe[j] + 100 or \"   \";\\\n      local mod = (j // 2) % num_terms + 1;\\\n      local mult = (j < #recipe) and recipe[j+1] * 4 or 0;\\\n      if mult > mult_max[mod] then\\\n        mult_max[mod] = mult;\\\n      end\\\n      acc_main[#acc_main + 1] = sub(multipliers, mult + 1, mult + 1);\\\n      if mod == num_terms then\\\n        acc_main[#acc_main + 1] = id + 100;\\\n        recipe_limit = recipe_limit + 1;\\\n      end\\\n    end\\\n  end\\\n  \\\n  factory.main_size = 4 * num_terms + 3;\\\n  acc_main[#acc_main + 1] = '\"';\\\n  factory.multipliers = {};\\\n  for i = 1, num_terms do\\\n    factory.multipliers[i] = sub(multipliers, 1, mult_max[i] + 1);\\\n  end;\\\n  factory.num_terms = num_terms;\\\n  factory.recipe_limit = recipe_limit;\\\n  return table.concat(acc_main);\\\n)}\n\n#lookup_item {lua(\\\n  acc = {};\\\n  for i = 1, #factory.items do\\\n    acc[i] = \"|\" .. (i + 10);\\\n  end\\\n  return factory.composite_string(\\\n    string.format(\\\n      [[index(\"%s\", \"|\" . sub(gsg({data_name}), %d * (i + 1), 2), 0) / 3]],\\\n      table.concat(acc),\\\n      factory.main_size\\\n    ),\\\n    nil,\\\n    true --[[Get craft type info instead of tiers]]\\\n  );\\\n)}\n\n; Returns the set of lookup/multiplier terms that will be added in to form\n; the base of the value. Most of the data for this is pre-comupted by\n; get_data().\n#recipe_terms {lua(\\\n  acc = {};\\\n  for i = 1, factory.num_terms do\\\n    if i ~= 1 then\\\n      acc[#acc + 1] = \" + \";\\\n    end\\\n    acc[#acc + 1] = string.format(\\\n      [[max(0., ceil(gdg({queue_str} . sub(loop_data, %d, 3)) *\\\n        i2d(index(\"%s\", sub(loop_data, %d, 1), 0)) * 0.25))]],\\\n      factory.entry_size + 4 * i - 1,\\\n      factory.multipliers[i],\\\n      factory.entry_size + 4 * i + 2\\\n    );\\\n  end\\\n  return table.concat(acc);\\\n)}\n\n; This macro is used to test the type of an item, in order to efficiently\n; disable the count. Item groups don't have a single real item associated,\n; but the count() still has to count something real to avoid a spurious log line.\n; Ore and lumps are also classified as groups so that they won't be counted,\n; because they're treated specially.\n#item_type sub(loop_data, {lua(return factory.entry_size - 1)}, 1)\n\n; These macros are used to test if the item is a dust. Dust gets its queue value\n; inflated by one, which has the effect of always ending up with 1 at the end.\n; (Although it doesn't prevent temporarily using all dust.)\n#recipe_item_trunc sub(loop_data, {lua(\\\n  return factory.entry_size + factory.main_size;\\\n)}, 2)\n#item_trunc(item) \"{lua(return factory.item_names[\"{item}\"].id + 10)}\"\n\n#prev_item sub(loop_data, {lua(return factory.entry_size)}, 3)\n#recipe_item sub(loop_data, {lua(\\\n  return factory.entry_size + factory.main_size;\\\n)}, 3)\n; The tier value is just the last digit of recipe_item\n#tier_value sub(loop_data, {lua(\\\n  return factory.entry_size + factory.main_size + 2;\\\n)}, 1)\n#recipe_item_name sub(loop_data, 0, index(loop_data, \" \", 0))\n#recipe_limit {lua(return factory.recipe_limit)}\n\n:global int factory_target\n:global double factory_target_amount\n\n; We use the name of the data variable to pull double-duty as a\n; hider for all the craft-queue variables.\n; This macro gives a prettier name for the global data string.\n#data_name \"<size=0><line-height=0>fdata\"\n\n:local int i\n:local string loop_data\n\n; Uncomment this for debugging. It needs to be before the data-hiding block.\n; Also uncomment the line below.\n;gss(\"debug\", \"\")\n\ngss({data_name}, {get_data(4)})\nloop:\n\n; Evaluates to an expression that results in an string containing encoded data\n; for this recipe. The first entry_size-1 characters are the in-game item name,\n; space-padded. Then comes the item type info: 0 is a regular item, 1 is a\n; crafted item, and 2 is an item-group. After that is a series of 3-number\n; strings, each of which is a craft-queue index.\n; The first is the index for the previous item, which is used to determine if\n; this is a continuation from a previous line. The next `num_terms`\n; terms are index values for queue values to add. After each term is a single\n; character which is a multiplier value. Following that is an index for the\n; current item, which is used as the index to set, and possibly also as an\n; index to read from.\n;\n; All of this is pulled from reading the appropriate sections of \"data\", mostly\n; as-is. However, there is a secondary lookup for the item name.\nloop_data = {lookup_item} . sub(\\\n  gsg({data_name}),\\\n  i * {lua(return factory.main_size)},\\\n  {lua(return factory.main_size + 3)}\\\n)\n\n; The core expression that does all the work. If this item is the target item,\n; then set the queue value to factory_target_amount - this ensures that the\n; target is always made, even if it already exists.\n; Otherwise, we set it to the sum of all of its recipe terms, minus the existing\n; count. This core value is the \"queue value\", and equals how many must be\n; crafted (if positive) or how many extra we have (if negative).\n; Since we are hardcoding the number of recipe terms that are handled in each\n; loop iteration to a small constant (4), there are additional wrinkles because\n; we may need to process the same item multiple times to get all the recipe\n; terms in. This means that if we're seeing the same item again, we add the\n; previous value of the variable and skip subtracting the count.\n; We also skip the count if the item is a group, since those don't have valid\n; items to count anyway.\n; In this way, we efficiently encode a sum that requires multiple passes.\nglobal.double.set({queue_str} . {recipe_item},\\\n  if({recipe_item} == i2s(factory_target + 100),\\\n    factory_target_amount,\\\n    (\\\n      if({prev_item} == {recipe_item}, global.double.get({queue_str} . {recipe_item}), 0.) +\\\n      {recipe_terms} -\\\n      if(\\\n        {prev_item} == {recipe_item} || {item_type} == \"2\",\\\n        0.,\\\n        if({recipe_item_trunc} == {item_trunc(dust)}, -1., 0.) + count({recipe_item_name}, index(\" 0123456789\", {tier_value}, 0))\\\n      )\\\n    )\\\n  )\\\n)\ni = i + 1\n; Uncomment this line for debugging. It will show the quantities and ids of all\n; items that need to be produced. You will also need to enable another line above.\n;gss(\"debug\", gsg(\"debug\") . if(gdg({queue_str} . {recipe_item}) > 0., \"<br>\" . {recipe_item} . \" \" . gdg({queue_str} . {recipe_item}), \"\"))\ngotoif(loop, i < {recipe_limit})\n\n; We use a global variable when a local variable would do just fine,\n; because we want to initialize this particular global variable inside\n; the variable-hiding block. It will be used later in the produce scripts.\n:global int _tier\n\n_tier = 10\ntierloop:\n\n{add_queue(_tier, dust, max(0., ({get_queue(_tier, lump)} - if(_tier == 10, 0., count(\"lump\", min(9, _tier)))) * 4.0))}\n{add_queue(_tier, ore, max(0., min(count(\"ore\", _tier), ceil({get_queue(_tier, dust)} / 2.))))}\n\ngotoif(nolumps, _tier == 1 | count(\"ore\", _tier) + count(\"dust\", _tier) == 0.)\n{add_queue(-1 + _tier, lump, max(0., {get_queue(_tier, dust)} - {get_queue(_tier, ore)} * 2.))}\nnolumps:\n\n_tier -= 1\ngotoif(tierloop, _tier > 0)\n\n; If we're missing the resources needed to complete the recipe, set error.\ngss(\\\n  {action},\\\n  if(\\\n    {get_queue(1, ore)} * 2. < {get_queue(1, dust)},\\\n    \"<color=#fb3>Missing \" . ({get_queue(1, dust)} - {get_queue(1, ore)} * 2.) . \" T1 dust<br>and/or higher tier dust/ore!</color>\",\\\n    if(\\\n      {get_queue(1, rubber)} > 0.,\\\n      \"<color=#fb3>Missing \" . {get_queue(1, rubber)} . \" rubber!</color>\",\\\n      \"\"\\\n    )\\\n  )\\\n)\n\n; This must come before the unset, to avoid ordering mishaps.\ngss(\"fhide2\", \"</line-height></size>\")\n\n; If there's an error, unset target to cancel crafting and clean up future\n; iterations. (This leaves some mess behind if the target is changed to something\n; else without resetting AI, but it should be good enough.)\n{set_raw(factory_target, if(\\\n  contains(gsg({action}), \"<\"),\\\n  0.,\\\n  {get_raw(factory_target)}\\\n))}\n"],["produce",":import factory constants\n\n:name {script_name(produce)}\n\n:global int _tier\n\n:local double previous_amount\n\nkey.{left}()\nkey.{right}()\n\nisopen(\"factory\")\n\n; If we were launched via key impulse, invoke the UI immediately to start turbo,\n; and set action to signal which key was pressed. Otherwise, we're being called\n; as a produce script.\nexecute(if(contains(impulse(), \"key.\"), \"{script_name(ui)}\", \"###badname###\"))\ngotoif(end, contains(impulse(), \"key.\"))\n\nprevious_amount = count(\"rubber\", 1)\nproduce(\"rubber\", 1, {get_queue(1, rubber_plate)}, \"presser\")\n{subtract_queue(1, rubber_plate, (previous_amount - count(\"rubber\", 1)))}\n\n_tier = 1\ntierloop:\n\nexecutesync(\"{script_name(produce dust)}\")\nstop(\"{script_name(produce dust)}\")\ngotoif(nexttier, _tier > 3 & {get_queue((_tier - 2) / 2, chip)} > 0. | _tier > 4 & {get_queue(_tier - 4, motor)} > 0.)\n\nexecutesync(\"{script_name(produce circuits)}\")\nstop(\"{script_name(produce circuits)}\")\nexecutesync(\"{script_name(produce plates)}\")\nstop(\"{script_name(produce plates)}\")\n\nnexttier:\n_tier += 1\ngotoif(tierloop, _tier < 11)\n\nend:\ngss({action}, if(\\\n contains(impulse(), \"key.\"),\\\n if(\\\n   contains(impulse(), \"key.{left}\"),\\\n   \"1\",\\\n   \"-1\"\\\n ),\\\n gsg({action})\\\n))\n"],["produce dust",":import factory constants\n\n:name {script_name(produce dust)}\n\n:global int _tier\n:local double previous_amount\n\ngotoif(noprocessores, active(\"crusher\"))\nprevious_amount = count(\"ore\", _tier)\nproduce(\"ore\", _tier, {get_queue(_tier, ore)}, \"crusher\")\n{subtract_queue(_tier, dust, (previous_amount - count(\"ore\", _tier)) * 2.)}\n{subtract_queue(_tier, ore, previous_amount - count(\"ore\", _tier))}\nnoprocessores:\n\ngotoif(notierupdust, _tier == 10 | active(\"mixer\"))\ncraft(\"lump\", _tier, min(\\\n  min(\\\n    (count(\"dust\", _tier) - 1.) / 4.,\\\n    count(\"dust\", _tier + 1)\\\n  ),\\\n  {get_queue(_tier, lump)} - count(\"lump\", _tier)\\\n))\nprevious_amount = count(\"lump\", _tier)\nproduce(\"lump\", _tier, min(previous_amount, {get_queue(_tier, lump)}), \"mixer\")\n{subtract_queue(_tier, dust, previous_amount - count(\"lump\", _tier))}\n{subtract_queue(_tier, lump, previous_amount - count(\"lump\", _tier))}\nnotierupdust:\n\ngotoif(noproduceingot, active(\"oven\") | (if(_tier == 10, 0., ({get_queue(_tier, lump)} - count(\"lump\", min(_tier, 9)))) * 4. > 2. * min(0., count(\"dust\", _tier) - ({get_queue(_tier, ingot)})) & count(\"dust\", _tier) < 2. * ({get_queue(_tier, ingot)})))\nprevious_amount = count(\"dust\", _tier)\nproduce(\"dust\", _tier, min(previous_amount - 1., {get_queue(_tier, ingot)}), \"oven\")\n{subtract_queue(_tier, ingot, previous_amount - count(\"dust\", _tier))}\nnoproduceingot:\n\nwait(0.0)\n"],["produce plates",":import factory constants\n\n:name {script_name(produce plates)}\n\n:global int _tier\n:local double previous_amount\n:local double limit\n\nprevious_amount = count(\"ingot\", _tier)\nproduce(\"ingot\", _tier, min(previous_amount, {get_queue(_tier, plate)}), \"presser\")\n{subtract_queue(_tier, plate, (previous_amount - count(\"ingot\", _tier)))}\nnoproduceplates:\n\nprevious_amount = count(\"plate\", _tier)\nproduce(\"plate\", _tier, min(previous_amount, {get_queue(_tier, pipe)}), \"shaper\")\n{subtract_queue(_tier, pipe, (previous_amount - count(\"plate\", _tier)))}\nnoproducepipes:\n\ngotoif(noproducedenseplates, active(\"presser\"))\nprevious_amount = count(\"plate.stack\", _tier)\nproduce(\"plate.stack\", _tier, min(previous_amount, {get_queue(_tier, dense_plate)}), \"presser\")\n{subtract_queue(_tier, dense_plate, (previous_amount - count(\"plate.stack\", _tier)))}\nnoproducedenseplates:\n\nprevious_amount = count(\"block\", _tier)\nproduce(\"block\", _tier, min(previous_amount, {get_queue(_tier, dense_block)}), \"boiler\")\n{subtract_queue(_tier, dense_block, (previous_amount - count(\"block\", _tier)))}\nnoproducedenseblocks:\n\nwait(0.0)\n"],["produce circuits",":import factory constants\n\n:name {script_name(produce circuits)}\n\n:global int _tier\n:local double previous_amount\n\nexecutesync(\"{script_name(produce misc)}\")\nstop(\"{script_name(produce misc)}\")\n\nprevious_amount = count(\"ingot\", _tier)\nproduce(\"ingot\", _tier, min(previous_amount, ceil({get_queue(_tier, cable)} / 2.)), \"refinery\")\n{subtract_queue(_tier, cable, 2. * (previous_amount - count(\"ingot\", _tier)))}\n\nprevious_amount = count(\"cable\", _tier)\nproduce(\"cable\", _tier, min(previous_amount, {get_queue(_tier, circuit)}), \"assembler\")\n{subtract_queue(_tier, circuit, (previous_amount - count(\"cable\", _tier)))}\n\nprevious_amount = count(\"plate\", _tier)\nproduce(\"plate\", _tier, min(previous_amount, {get_queue(_tier, board)}), \"refinery\")\n{subtract_queue(_tier, board, (previous_amount - count(\"plate\", _tier)))}\n\nwait(0.0)\n"],["produce misc",":import factory constants\n\n:name {script_name(produce misc)}\n\n:global int _tier\n:local double previous_amount\n\nprevious_amount = count(\"cable\", _tier)\nproduce(\"cable\", _tier, min(previous_amount, {get_queue(_tier, wire)}), \"refinery\")\n{subtract_queue(_tier, wire, (previous_amount - count(\"cable\", _tier)))}\n\nprevious_amount = count(\"ingot\", _tier)\nproduce(\"ingot\", _tier, min(previous_amount, ceil({get_queue(_tier, rod)} / 2.)), \"shaper\")\n{subtract_queue(_tier, rod, 2. * (previous_amount - count(\"ingot\", _tier)))}\n\nprevious_amount = count(\"rod\", _tier)\nproduce(\"rod\", _tier, min(previous_amount, ceil({get_queue(_tier, screw)} / 4.)), \"cutter\")\n{subtract_queue(_tier, screw, 4. * (previous_amount - count(\"rod\", _tier)))}\n\nprevious_amount = count(\"rod\", _tier)\nproduce(\"rod\", _tier, min(previous_amount, {get_queue(_tier, ring)}), \"shaper\")\n{subtract_queue(_tier, ring, (previous_amount - count(\"rod\", _tier)))}\n\nwait(0.0)\n"],["craft",":import factory constants\n:import recipes\n\n:name {script_name(craft)}\n\n:local double previous_amount\n:local int i\n:local string itemdata\n:local string group_data\n\n:global int factory_target\n\nkey.{up}()\nkey.{down}()\n\nisopen(\"factory\")\n\n; If we were launched via key impulse, invoke the UI immediately to start turbo,\n; and set action to signal which key was pressed. Otherwise, we're being called\n; as a produce script.\nexecute(if(contains(impulse(), \"key.\"), \"{script_name(ui)}\", \"###badname###\"))\ngotoif(group_abort, contains(impulse(), \"key.\"))\n\n; Craft all the items.\ncraftitems_loop:\nitemdata = {lua(return factory.composite_string(\"i/10\", \"craft\"))}\n\ndo_craft:\n; Because items and tiers start at 1, but i is zero-based, we have to add 1\n; or (pre-multiplying, 10) in these expressions.\n; However, tier is zero-based inside our indexing representation, so we don't\n; add it there.\nprevious_amount = count({get_name}, i%10 + 1)\ncraft({get_name}, i%10 + 1, {get_raw(10 + i)})\n{set_raw(10 + i, {get_raw(10 + i)} - (count({get_name}, i%10 + 1) - previous_amount))}\ninc:\n; This skips over tiers that don't exist for the given item, by using the\n; tier data embedded in \"itemdata\".\ni = i + if(i2s(i%10) == {tiers_char}, 10 - i%10, 1)\ngoto(if(i%10 != 0,\\\n     if({get_raw(10 + i)} > 0., do_craft, inc),\\\n     if(i < {items_count} * 10, craftitems_loop, crafting_done)))\ncrafting_done:\n\ngroup_data = \"{lua(\\\n  acc = {}\\\n  for i = 1, #factory.items do\\\n    local item = factory.items[i];\\\n    if item.craft_type ~= \"group\" then goto continue end\\\n    for j = 1, item.tier do\\\n      acc[#acc+1] = \"|\" .. (i * 10 + j + 99);\\\n      local recipe = item.recipes[j];\\\n      for k = 1, #recipe, 2 do\\\n        acc[#acc+1] = recipe[k] + 100;\\\n      end\\\n    end\\\n    ::continue::\\\n  end\\\n  acc[#acc+1] = \"|\";\\\n  return table.concat(acc);\\\n)}\"\n\ni = index(group_data, \"|\" . (factory_target + 100), 0) + 1\ncheck_group_loop:\ni += 3\ngoto(if(\\\n  i < 4, group_abort,\\\n  if(\\\n    sub(group_data, i, 1) == \"|\", group_complete,\\\n    if(\\\n      gdg({queue_str} . sub(group_data, i, 3)) > 0., group_abort,\\\n      check_group_loop\\\n    )\\\n  )\\\n))\n\ngroup_complete:\n{set_raw(factory_target, 0.)}\ngroup_abort:\ngss({action}, if(\\\n contains(impulse(), \"key.\"),\\\n if(\\\n   contains(impulse(), \"key.{up}\"),\\\n   \"1\",\\\n   \"-1\"\\\n ),\\\n gsg({action})\\\n))\n"],["init",":import factory constants\n\n:name {script_name(init)}\n\nwakeup()\nopen.factory()\n\nisopen(\"factory\")\n\n:global double factory_target_amount\n:global int factory_target\n\n:global int turbo.cycles\n:global int turbo.cycles.max\n\n:local double target_value\n\n; Run the UI, to display the current pending item.\nexecute(\"{script_name(ui)}\")\n\n; Initial dispatch on entering the factory to determine if we are resuming\n; a crafting operation or waiting to launch a new one. This is done outside\n; of turbo, so that we never invoke turbo if we don't need to.\ngotoif(wait_loop, {get_raw(factory_target)} == 0.)\n\n; The core factory cycle. We do each loop of factory production within\n; one call of nested turbo start/stop, which executes within one frame.\n;\n; This loop handles both calculating recipes via \"run_recipes\"\n; and crafting via \"craft\". This is done with conditional execution,\n; in order to save lines for future possible features.\nbegin_cycle:\nexecutesync(\"TE2.2:start\")\n\n; Here we up the number of cycles so that it will be enough to\n; calculate the recipes or produce items. We intentionally have a\n; frame break between the recipe calculation and the beginning of crafting\n; to prevent jarring lag on startup.\n; This formula ensures that we don't accidentally step on another script\n; that needs more cycles, and also that we get the full amount of cycles\n; even if something else started turbo before us.\nturbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)\n\n; We have to save this, because the value can change as a result of executing\n; later scripts.\ntarget_value = {get_raw(factory_target)}\n\n; All conditional execution in the loop is behind this condition. If it\n; is true, then we're here because of `ui`. Otherwise,\n; this is a regular crafting iteration.\n\n; There are extra checks for isopen(\"factory\") here. The main check is at the\n; bottom of the loop, but that happens before the end of the frame, so there will\n; be one more frame where we have exited the factory, but the loop still runs.\n; Normally, this wouldn't be an issue (all of the scripts will perform no actions\n; and leave the variables in the same state), but \"produce\" and \"craft\" have a\n; startup condition of isopen(\"factory\"), since they do double-duty as UI impulse\n; scripts as well.\n; So, we have to protect them, otherwise executesync() will hang when it hits\n; the false condition, leading to a stuck script.\nexecutesync(if(\\\n  isopen(\"factory\"),\\\n  if(target_value > 0., \"{script_name(produce)}\", \"{script_name(run_recipes)}\"),\\\n  \"###badname###\"\\\n))\nstop(if(target_value > 0., \"{script_name(produce)}\", \"{script_name(run_recipes)}\"))\nexecutesync(if(\\\n  target_value > 0. && isopen(\"factory\"),\\\n  \"{script_name(craft)}\",\\\n  \"###badname###\"\\\n))\nstop(if(target_value > 0., \"{script_name(craft)}\", \"\"))\n\n; Clear factory_target to indicate that crafting is done, if it is, in fact, done.\nfactory_target = if({get_raw(factory_target)} > 0., factory_target, 0)\n; Re-display the UI when crafting is done.\nexecute(if(factory_target == 0, \"{script_name(ui)}\", \"###badname###\"))\n\n; Clear this (unconditionally), to signal that we're not starting a new crafting\n; pass.\nfactory_target_amount = 0.\n\nexecutesync(\"TE2.2:stop\")\n\n; Here we either return to the next iteration of the production loop,\n; or stall on this instruction until we need to launch the factory.\n; Because there is always 1 extra cycle of turbo after \"TE2.2:stop,\" there\n; is enough time to execute this goto and have only a single frame break\n; before starting turbo again at the top of the loop.\nwait_loop:\ngotoif(\\\n  if(max(factory_target_amount, {get_raw(factory_target)}) > 0.,\\\n    begin_cycle, wait_loop\\\n  ),\\\n  isopen(\"factory\")\\\n)\n\n; Remove the UI status so it doesn't clutter the variables when we're outside the\n; factory.\n; This is safe to repeat, when turbo is looping at the end of the script.\ngss({status}, \"</size>\")\n"],["ui",":import factory constants\n:import worker_storage_lib\n\n:name {script_name(ui)}\n\n:local double count\n:local int visible_tier\n:local int tier\n:local int category\n:local int item\n:local int cursor\n\n:global int turbo.cycles\n:global int turbo.register\n:global int factory_target\n:global double factory_target_amount\n\nkey.{start}()\n\nisopen(\"factory\")\n\n; Because of how turbo exec works, we can't launch turbo on the frame the script\n; starts by calling \"TE2.2:start\", if we are being called from another script.\n; We can only do it by changing turbo.register directly, saving a layer of\n; script execution.\n; (This is because of the relative positioning of TE.turbo vs our script;\n; usually we would be before, but when we are first launched our script is after.)\nturbo.register += 1\n\n; Use worker_storage_lib to find a worker_slot to use for permanent storage.\n:local int worker_slot\n{worker_lib_line_1([factory])}\n{worker_lib_line_2}\n\n; Split out the worker data into separate variables. We take advantage of this\n; time to also perform increment/decrement, since we can easily combine it in\n; this stage. We don't bother checking if we've got a valid slot, because if we\n; don't, we'll simply fail to parse and get the fallback value.\n\n#action_num s2i(gsg({action}), 0)\n; Is the u/d action valid for this position?\n; Using contains() instead of == and chained compares saves a lot of import space.\n#is_ud(pos) contains(impulse() . cursor, \":craft{pos}\")\n\ncursor = min(9, max(0,\\\n  s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 11, 1), 0) +\\\n  if(contains(impulse(), \":produce\"), {action_num}, 0)\\\n))\ncount = min(9999999., max(1.,\\\n  s2d(sub(worker.name(worker_slot), {len({worker_prefix})}, 7), 1.) +\\\n  if(contains(impulse(), \":craft\"), i2d({action_num} * 10^(cursor - 3)), 0.)\\\n))\n\n#num_categories {lua(return #factory.categories)}\ncategory = (\\\n  s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 8, 1), 0) +\\\n  if({is_ud(1)}, {action_num}, 0) +\\\n  {num_categories}\\\n) % {num_categories}\n\n; Because math expressions are so expensive, in terms of import space, it's best\n; to just pre-compute tables of the next/previous item to go to for every item.\n; To avoid duplicating expressions, we also make a no-op table for the case where\n; we're not incrementing or decrementing.\n{lua(\\\n  function factory.item_inc_table(inc)\\\n    local acc = {}\\\n    local default = string.format(\"%02d\", factory.categories[1].default - 1)\\\n    for i = 1, #factory.categories do\\\n      local cat = factory.categories[i]\\\n      local cat_size = cat.last - cat.first + 1\\\n      for j = cat.first, cat.last do\\\n        acc[j] = string.format(\"%02d\", (j + inc - cat.first) % cat_size + cat.first - 1)\\\n      end\\\n    end\\\n    for i = 1, #factory.items do\\\n      acc[i] = acc[i] or default\\\n    end\\\n    return table.concat(acc)\\\n  end\\\n)}\n#item_inc_table(inc) {lua(return factory.item_inc_table({inc}))}\n#category_defaults {lua(\\\n  local acc = {}\\\n  for i = 1, #factory.categories do\\\n    acc[i] = string.format(\"%02d\", factory.categories[i].default - 1)\\\n  end\\\n  return table.concat(acc)\\\n)}\n\n; Items in this variable are zero-indexed, as opposed to their regular ids, which\n; start from 1.\nitem = s2i(\\\n  if({is_ud(1)},\\\n    sub(\\\n      \"{category_defaults}\",\\\n      category * 2,\\\n      2\\\n    ),\\\n    sub(\\\n      if({is_ud(0)},\\\n        if(\\\n          contains(gsg({action}), \"-1\"),\\\n          \"{item_inc_table(-1)}\",\\\n          \"{item_inc_table(1)}\"\\\n        ),\\\n        \"{item_inc_table(0)}\"\\\n      ),\\\n      s2i(\\\n        sub(worker.name(worker_slot), {len({worker_prefix})} + 9, 2),\\\n        {lua(return factory.categories[1].default - 1)}\\\n      ) * 2,\\\n      2\\\n    )\\\n  ),\\\n  0\\\n)\n\n; The distinction between \"tier\" and \"visible_tier\" has to do with the fact that\n; items have different tier maximums. When a user is scrolling through different\n; items, if the \"tier\" is T10 (represented as \"9\" in our zero-indexed scheme),\n; then the \"visible_tier\" will change to fit the maximum tier for the item, while\n; the tier remains at T10. However, if the item is a producer (max of T5), and\n; the user moves the cursor to the tier field and presses \"W\", the attempt to\n; increment \"tier\" will fix it at a new value of T5 (4).\n#tier_data {lua(\\\n  local acc = {};\\\n  for i = 1, #factory.items do\\\n    local item = factory.items[i];\\\n    acc[i] = string.format(\"%d\", item.tier - 1);\\\n  end\\\n  return table.concat(acc)\\\n)}\n\n; Expression to load the saved tier data from the worker name, including\n; a default value when there is no data.\n#saved_worker_tier s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 7, 1), 0)\n\n; It makes the most sense to set visible_tier first. There is a complication\n; when adjusting the tier down; in this case, we reduce the maximum bounds by\n; one, so that (for instance) if the max tier is T5, and the current tier is T10,\n; we'll properly clip the visible_tier to T4 after subtracting 1 to get T9.\n; This type of adjustment isn't needed (or wanted) in the other direction, or\n; when the tier isn't changing.\nvisible_tier = max(0,\\\n  min(s2i(sub(\"{tier_data}\", item, 1), 9) +\\\n      if({is_ud(2)} && gsg({action}) == \"-1\", -1, 0),\\\n    {saved_worker_tier} + if({is_ud(2)}, {action_num}, 0)\\\n  )\\\n)\ntier = if({is_ud(2)}, visible_tier, {saved_worker_tier})\n\n; Finally, construct the visible name for use in the variable.\n{lua(\\\n  local names = {}\\\n  local name_starts = {}\\\n  local name_sizes = {}\\\n  local name_len = 0\\\n\\\n  for i = 1, #factory.items do\\\n    local name = factory.items[i].name\\\n    names[i] = name\\\n    name_starts[i] = string.format(\"%03d\", name_len)\\\n    name_len = name_len + #name\\\n    name_sizes[i] = string.format(\"%02d\", #name)\\\n  end\\\n  factory.name_data = table.concat(names)\\\n  factory.name_starts = table.concat(name_starts)\\\n  factory.name_sizes = table.concat(name_sizes)\\\n  factory.items_count = #factory.items\\\n\\\n  names = {}\\\n  for i = 1, #factory.categories do\\\n    names[i] = factory.categories[i].name\\\n  end\\\n  factory.category_names = table.concat(names)\\\n)}\n#name_data {lua(return factory.name_data)}\n#name_starts {lua(return factory.name_starts)}\n#name_sizes {lua(return factory.name_sizes)}\n#category_names {lua(return factory.category_names)}\n\n; Set this variable in order to begin a variable-hiding block.\n; It looks like a no-op, but really we're ensuring that it has a slot in the\n; globals table, even if its value empty - in this case, what we care about\n; is the *name*, which starts with \"<size=0>\".\n; Do this *after* all the other work, to give turbo register time to\n; set its variables, in case we're doing this right at startup.\ngss({action}, gsg({action}))\n\n; This no-op exists *solely* to adjust the number of cycles, so that we don't\n; land on the wrong number of turbo.cycles at the end and falsely think that\n; turbo is not working.\nwait(0.)\n\n; Do conditional stuff, depending on if we're launching the factory.\n; We set all these variables always, so that they'll have a consistent order,\n; and also to save lines instead of jumping over this block.\n\n#valid_start contains(factory_target . impulse(), \"0key.\")\n; This (maybe) launches the factory. We need to do it soon enough to not\n; interrupt turbo, see the comment on \"TE2.2:stop\", below.\nfactory_target_amount = if({valid_start}, count, factory_target_amount)\n\n; Only set factory_target if it's zero, which indicates that the factory is idle.\n; This prevents repeated keypresses from messing things up.\nfactory_target = if({valid_start}, (item + 1) * 10 + visible_tier, factory_target)\n\n; Construct the status line. There's a *lot* that goes into this.\n;\n; For starters, we fake the variable - it's not really \"make\", but rather a\n; totally different variable that's less likely to collide. The true variable name\n; is never seen, because it's still part of the <size=0> block. We put our fake\n; variable name after. We do all this so that we can \"unset\" the variable by\n; just changing its value - this way, it's not truly unset, and we don't have\n; issues with variable ordering as a result.\n;\n; This also means we can change the variable name to something else, like\n; \"error\", if we need to, all without actually creating a new variable or\n; changing ordering.\n;\n; All the clauses are dynamically created on the fly here. We also create the\n; \"cursor\" by highlighting a specific part of the result in green. This involves\n; a great deal more complexity.\n#curs_col 2f4\n\ngss({status}, if(\\\n  worker_slot == 200,\\\n  \"</size>error=<color=#fb3>No available workers!</color>\",\\\n  if(\\\n    turbo.cycles == 0,\\\n    \"</size>error=<color=#fb3>Turbo exec is not working</color>\",\\\n    \"</size>make=<color=#fff>\" .\\\n    sub(d2s(10000000. + count), 1, 9 - cursor) .\\\n    \"</color><color=#{curs_col}>\".\\\n    sub(d2s(10000000. + count), 10 - cursor, 1) .\\\n    \"</color><color=#fff>\".\\\n    sub(d2s(10000000. + count), 11 - cursor, 10) .\\\n    \"<smallcaps>x</smallcaps><color=#\" .\\\n    if(cursor == 2, \"{curs_col}>T\", \"fff>T\") .\\\n    (visible_tier + 1) .\\\n    if(cursor == 1, \"</color> <color=#{curs_col}>\", \"</color> <color=#fff>\") .\\\n    sub(\"{category_names}\", category * 4, 4) .\\\n    if(cursor == 0, \"</color> ...<br><color=#{curs_col}>\", \"</color> ...<br><color=#fff>\") .\\\n    sub(\"{name_data}\", s2i(sub(\"{name_starts}\", item * 3, 3), 0),\\\n      s2i(sub(\"{name_sizes}\", item * 2, 2), 0)) .\\\n    \"<br></color></color>\" . if(\\\n      contains(impulse() . gsg({action}), \":init<\"),\\\n      gsg({action}),\\\n      if(\\\n        factory_target == 0,\\\n        \"<color=#0df>{up}{left}{down}{right} moves, {start} crafts</color> \",\\\n        \"<color=#ff0>Crafting...</color>\"\\\n      )\\\n    )\\\n  )\\\n))\n\n; \"init\" will take over as soon as factory_target_amount gets set 3 lines\n; above; it will call its own \"TE2.2:start\" and thus prevent the frame from\n; ending before this line takes effect.\n; We need two cycles in-between to have a seamless transition.\n; We change the variable directly, instead of calling \"TE2.2:stop\", for parity\n; with the way we start: This avoids some edge cases when turbo is incorrectly\n; installed. It also is fine in this case, because we don't need to wait for\n; the end of the frame.\nturbo.register -= 1\n\n; Setting the data back in the worker is moved way down to the bottom, to function\n; as the \"filler\" action that can be repeated while the script is waiting for\n; the frame to end. We can't use of the actions the set global variables for this,\n; because they may need to be modified later in the frame, and thus setting them\n; here in a loop would overwrite the value.\nworker.setName(if(worker_slot < 100, worker_slot, worker_slot - 100),\\\n  \"{worker_prefix}\" . sub(d2s(10000000. + count), 1, 7) . tier . category .\\\n  sub(i2s(100 + item), 1, 2) . cursor\\\n)\n"]]}}
```

The workspace should have the following scripts, in this order:

`factory constants 0 0 0`<br>
`factory macros 0 0 0`<br>
`worker_storage_lib 0 0 0`<br>
`recipes 0 0 0`<br>
`run_recipes 0 0 15`<br>
`produce 2 1 16`<br>
`produce dust 0 0 16`<br>
`produce plates 0 0 14`<br>
`produce circuits 0 0 12`<br>
`produce misc 0 0 13`<br>
`craft 2 1 14`<br>
`init 2 1 15`<br>
`ui 1 1 16`<br>

## Changelog

### V3.0.4

Change to requiring Turbo Exec v2.2.

```
Bundle size: 75596   Scripts: 9   Max lines: 16
```

### V3.0.3

Bugfix: Work around a game bug with executing empty scripts. This could
formerly cause your logs to become huge while using the factory, if you had an
empty script named "" (empty string).

```
Bundle size: 75596   Scripts: 9   Max lines: 16
```

### V3.0.2

Bugfix: Fix script getting stuck (and having multiple copies) when exiting
during crafting.

```
Bundle size: 75528   Scripts: 9   Max lines: 16
```

### V3.0.1

Bugfix: Crafting should only be enabled in the Factory.

```
Bundle size: 75364   Scripts: 9   Max lines: 16
```

### V3.0.0

The UI rewrite.

* Editing "launch factory craft" is gone. (That whole script is gone.)
* There is now a shiny new UI, which is navigated with WASD. Items, tiers, and
  quantities are selected on-screen dynamically. The selections are remembered
  across AI restarts by using worker-name storage.
* More robust checking for when Turbo Exec isn't functioning.

```
Bundle size: 75316   Scripts: 9   Max lines: 16
```

### V2.2.0

The "more helpful errors" release.

* Add spell-check support (contributed by cl1694) to suggest correct item-name
  spellings when the item can't be found.
* Add error-handling for if target_type is changed by name instead of by value,
  as well as running without modifying target_type.
* Finally add checking for insufficient ore/rubber at startup, and show errors
  instead of uptiering needlessly.

Also group everything into a package, for convenience and orginazation.

```
Bundle size: 81073   Scripts: 10   Max lines: 16
```

### V2.1.1

Fix a bug where trying to produce ore made producers instead.

```
Bundle size: 68768   Scripts: 9   Max lines: 16
```

### V2.1.0

***I forgot to update the version number in the script, it will show as v2.0.1***

Fix a bug with crushing and mixing dust that would cause various issues
if you were low on dust.

Add "line-height=0" so that there isn't a big blank space in the variables list.

```
Bundle size: 68768   Scripts: 9   Max lines: 16
```

### V2.0.1

Add rubber saplings.

```
Bundle size: 68700   Scripts: 9   Max lines: 16
```

### V2.0.0

Change to using Turbo Exec V2.

All global variables are now hidden internally, instead of relying on turbo
exec to do it (since V2 no longer messes with the variable display).
```
Bundle size: 68517   Scripts: 9   Max lines: 16
```

### V1.0.1

This moves hammers and T1 pressers to tier 2, so that when you craft the item groups you can
immediately scan the entire group, instead of needing to wait on items in the next group.

Also, implement a versioning scheme that shows up in the script names.
```
Bundle size: 69146   Scripts: 10   Max lines: 16
```

### V1.0.0

Initial release. This release is identifiable with plain names, because I hadn't thought to do versioning yet.

The main feature is the much smaller size, compared to Xenos', which it was evolved from.
Xenos' bundle is 309696 bytes, taking more than a minute to import and often causing people to close the program due to the "not responding dialog".
It is also 32 scripts big, and requires 22 lines.

The other feature is built-in item groups, instead of needing them added as a separate download.
```
Bundle size: 69142   Scripts: 10   Max lines: 16
```
