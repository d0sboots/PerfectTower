D0S.Factory: {
  factory_constants: {
    :import factory macros

    #version v3.2.3

    ; Everything in the list below is a valid target for automation, and can be
    ; assigned to the "target_type" variable in "lanuch factory craft".
    ; For example, "make(oven, 10, "machine.oven")" indicates that "oven" is a valid
    ; item, usable from tiers 1-10, with the internal game name of "machine.oven"
    ; (which you don't need to worry about.)
    ; Thus you can enter "oven" in the box in the in-game editor (without the quotes).

    ; If you add or change this list, mind this constraint:
    ; * All the crafted items have to come before the rest of the items.
    ; * All the item-groups must be in a single block.
    ; * Prefer keeping things in alphabetical order within categories, because
    ;   they are ordered the same way when presented in-game.

    ; ===== VALID IDS =====

    ; *** To reiterate, just use the name part (i.e. "white_producer"), not the whole thing! ***

    ; ----- CRAFTED ITEMS -----

    ; Producers, named by building, tiers 1-5
    {make(arcade_producer, 5, "producer.arcade")}
    {make(construction_firm_producer, 5, "producer.constructionFirm")}
    {make(exotic_producer, 1, "producer.exoticgems")}
    {make(factory_producer, 5, "producer.factory")}
    {make(gem_producer, 1, "producer.gems")}
    {make(headquarters_producer, 5, "producer.headquarters")}
    {make(laboratory_producer, 5, "producer.laboratory")}
    {make(mine_producer, 5, "producer.mine")}
    {make(museum_producer, 5, "producer.museum")}
    {make(powerplant_producer, 5, "producer.powerplant")}
    {make(pumpkin_producer, 1, "pumpkin.producer")}
    {make(shipyard_producer, 5, "producer.shipyard")}
    {make(statue_of_cubos_producer, 5, "producer.statueofcubos")}
    {make(town_producer, 5, "producer.town")}
    {make(tradingpost_producer, 5, "producer.tradingpost")}
    {make(workshop_producer, 5, "producer.workshop")}

    ; Boosters, tiers 1-3
    {make(acceleration_booster, 3, "booster.acceleration")}
    {make(machine_booster, 3, "booster.machines")}
    {make(production_booster, 3, "booster.production.regular")}
    {make(resource_booster, 3, "booster.resource.drops")}

    {category(prod, town_producer, arcade_producer, resource_booster)}

    ; Machines, tiers 1-10
    {make(assembly, 10, "machine.assembler")}
    {make(belt, 10, "machine.transportbelt")}
    {make(boiler, 10, "machine.boiler")}
    {make(crusher, 10, "machine.crusher")}
    {make(cutter, 10, "machine.cutter")}
    {make(mixer, 10, "machine.mixer")}
    {make(oven, 10, "machine.oven")}
    {make(presser, 10, "machine.presser")}
    {make(refiner, 10, "machine.refinery")}
    {make(shaper, 10, "machine.shaper")}

    {category(mach, belt, assembly, shaper)}

    ; Various crafted parts
    {make(block, 10, "block")}
    {make(chip, 5, "chip")}
    {make(hammer, 1, "hammer")}
    {make(insul_cable, 10, "cable.insulated")}
    {make(motor, 10, "motor")}
    {make(pump, 10, "pump")}
    {make(rainbow_dust, 1, "dust.rainbow")}
    {make(rubber_sapling, 1, "sapling.rubber")}
    {make(stacked_plate, 10, "plate.stack")}
    {make(stacked_pumpkin, 1, "pumpkin.stack")}
    {make(void_sapling, 1, "sapling.void")}

    {category(crft, chip, block, void_sapling)}

    ; Transforms ore into dust, tiers 1-10
    ; Because of an implementation detail, this must come before any
    ; scannable items.
    ; This doesn't show up in any category in the UI.
    {special(ore, 10, "ore")}

    ; ----- SCANNABLE ITEM GROUPS -----
    ; These are not real items, but rather groups of items that will be made together
    ; if you select one of these names. They are meant for use with the Crafter, to
    ; crank out sets of items to scan quickly. You will want to set the quantity to 1000.

    ; Notes on using item groups:
    ; * SCAN YOUR ORES FIRST! The factory can and will consume your ore to make stuff,
    ;     and it takes a long time to get 1000 T10 ore.
    ; * The quantity works a little differently than normal items. Instead of making
    ;     1000 items each time, running it again will top off everything to be
    ;     *at* the quantity of 1000 items.
    ; * If you craft a higher tier after a lower tier, it will consume the results
    ;     of the first craft to make the higher tier. Scan all the items first, before
    ;     moving on to the next tier!
    ; * None of these groups include Gem Producers or Exotic Producers. They are too
    ;     expensive in comparison to other things, craft them on your own when you
    ;     judge the time is right.

    ; Makes *everything* (expect special producers and lumps) of the given tier.
    ; This is the combination of "chips_and_prods", "machines", and "parts".
    ; Requires x10 and high processing speed to have a hope of completing in a
    ; reasonable amount of time for T5 and T10.
    ; You need Quantum Warehouse to have enough space for this at higher tiers!
    {group(all, 10)}

    ; All the tiers of chips. Warning: Expensive. Input this as tier 1.
    {group(chips, 1)}

    ; Producers + the chip of the corresponding tier. This is everything that
    ; exists in tier range 1-5, for convenience.
    {group(chip_and_prods, 5)}

    ; All machines. Tiers 1-10
    {group(machines, 10)}

    ; All ingredients and parts. Tiers 1-10. Doesn't include ore (scan that before
    ; starting) or lumps (due to technical limitations). Lumps aren't required
    ; for anything currently though.
    ; Includes rubber plates at tier 1 and hammers at tier *2*.
    ; Rubber trees are at tier 9 because of their ore.
    {group(parts, 10)}

    ; All producers, except for special producers. Tiers 1-5
    {group(producers, 5)}

    {category(grup, all, all, producers)}

    ; ----- INGREDIENTS AND PRODUCED PARTS -----

    ; Parts, tiers 1-10
    {item(anti_pumpkin, 1, "pumpkin.anti")}
    {item(board, 10, "plate.circuit")}
    {item(cable, 10, "cable")}
    {item(carved_pumpkin, 1, "pumpkin.carved")}
    {item(circuit, 10, "circuit")}
    {item(dense_block, 10, "block.dense")}
    {item(dense_plate, 10, "plate.dense")}
    {item(ingot, 10, "ingot")}
    {item(pipe, 10, "pipe")}
    {item(plate, 10, "plate")}
    {item(pumpkin_plate, 1, "pumpkin.plate")}
    {item(rainbow_ingot, 1, "ingot.rainbow")}
    {item(rainbow_plate, 1, "plate.rainbow")}
    {item(ring, 10, "ring")}
    {item(rod, 10, "rod")}
    {item(rubber_plate, 1, "plate.rubber")}
    {item(screw, 10, "screw")}
    {item(wire, 10, "wire")}

    {category(part, circuit, anti_pumpkin, wire)}

    ;Tries to make dust from ores and lower-tier dusts, tiers 1-10
    ; Doesn't appear in the UI
    {item(dust, 10, "dust")}

    ; Tiers up dust, tiers 1-9
    ; These are ore lumps, plus putting them into the mixer.
    ; There is no "only make ore lumps, without mixing them" option right now.
    ; Doesn't appear in the UI
    {special(lump, 9, "lump")}

    ; Can only be made from saplings
    ; Doesn't appear in the UI
    {item(void_essence, 1, "essence.void")}

    ; Can only be gotten through the Halloween event
    ; Doesn't appear in the UI
    {item(pumpkin, 1, "pumpkin")}

    ; Rubber, tier 1 only
    ; Doesn't appear in the UI
    {item(rubber, 1, "rubber")}

    ; ===== END OF VALID IDS =====
  }
  factory_macros: {
    ; Infrastructure for producing all the constants in the factory package.
    ; Since this is :imported, it can't produce any instructions.

    #script_name(name) D0S.factory {version}:{name}
    #garbage_requested {script_name(###badname###)}

    ; Key assignments. You can edit these here, or you can edit them later in the
    ; generated script (but you will have more places to modify).
    #up w
    #down s
    #left a
    #right d
    #start f

    ; Shared hidden variables for the UI
    #action "<size=0>fa#"
    #status "fs#"

    ; Produces the name of the queue variable for the given tier and item.
    #queue_str "cq"
    #queue(tier, item) -1 + 10 * ({item}) + {tier}

    ; Raw access to the queue. Not preferred, but better than using "queue"
    ; directly. Use for low-level optimization.
    #get_raw(raw_item) global.double.get({queue_str} . (100 + {raw_item}))
    #set_raw(raw_item, value) global.double.set({queue_str} . (100 + {raw_item}), {value})

    ; Helper macros for operating on the craft_queue. These should be
    ; used instead of direct access whenever possible.
    #get_queue(tier, item) {get_raw({queue({tier},{item})})}
    #set_queue(tier, item, value) {set_raw({queue({tier},{item})},{value})}

    ; Add/subtract a value from the queue. Although it expands to the same thing,
    ; it saves a lot of boilerplate in the source and makes it easier to understand
    ; what's going on.
    #add_queue(tier, item, value) {set_queue({tier},{item},{get_queue({tier},{item})} + {value})}
    #subtract_queue(tier, item, value) {set_queue({tier},{item},{get_queue({tier},{item})} - ({value}))}

    ; Used with factory.composite_string to extract the name from the
    ; returned data.
    #get_name sub(itemdata, 0, index(itemdata, " ", 0))

    ; These macros can only be called *after* factory.composite_string,
    ; i.e. later on in the script.
    #items_count {lua(return factory.items_count)}
    #tiers_char sub(itemdata, {lua(return factory.entry_size - 1)}, 1)

    {lua(\
      factory = {};\
      factory.items = {};\
      factory.item_names = {};\
      factory.categories = {};\
      factory.prods = {};\
      factory.prod_machines = {};\
      factory.name_max_size = 0;\
      factory.game_name_sizes = {};\
      factory.game_name_sizes.item = 0;\
      factory.game_name_sizes.craft = 0;\
      factory.game_name_sizes.group = 0;\
      factory.game_name_sizes.special = 0;\
      factory.group_map = {};\
      factory.group_map.item = 0;\
      factory.group_map.craft = 1;\
      factory.group_map.group = 2;\
      factory.group_map.special = 2; --[[Intentionally the same]]\
    \
      function factory.add_item(name, tiers, game_name, craft_type)\
        local item = {};\
        item.id = #factory.items + 1;\
        if item.id > 89 then\
          return "Too many items: Over the limit while adding " .. name;\
        end\
        item.name = name;\
        item.game_name = game_name;\
        item.tier = tiers;\
        item.craft_type = craft_type;\
        factory.items[item.id] = item;\
        factory.item_names[name] = item;\
        if #name > factory.name_max_size then\
          factory.name_max_size = #name;\
        end\
        if #game_name > factory.game_name_sizes[craft_type] then\
          factory.game_name_sizes[craft_type] = #game_name;\
        end\
        return ":const int " .. name .. " " .. #factory.items;\
      end\
    \
      function factory.composite_string(var, filter, use_group_info)\
        local acc = {};\
        local size = 0;\
        local first = #factory.items;\
        local last = 0;\
        local group_map = factory.group_map;\
        \
        if filter == nil then\
          size = math.max(factory.game_name_sizes["item"], factory.game_name_sizes["craft"]);\
        else\
          size = factory.game_name_sizes[filter];\
        end\
        size = size + 1;\
        local fmt = "%-" .. size .. "s%d";\
        size = size + 1;\
        acc[1] = 'sub("';\
        for i = 1, #factory.items do\
          local item = factory.items[i];\
          if filter == nil or item.craft_type == filter then\
            if use_group_info then\
              acc[#acc + 1] = string.format(fmt, item.game_name, group_map[item.craft_type]);\
            else\
              acc[#acc + 1] = string.format(fmt, item.game_name, item.tier - 1);\
            end\
            if i < first then first = i end\
            if i > last then last = i end\
          end\
        end\
        acc[#acc + 1] = '", ' .. size .. " * (" .. var .. "), " .. size .. ')';\
        factory.items_count = last - first + 1;\
        factory.entry_size = size;\
        return table.concat(acc);\
      end\
    \
      function factory.add_category(name, ...)\
        local category = {}\
        factory.categories[#factory.categories + 1] = category\
        category.name = name\
        local name1, name2, name3 = "default", "first", "last"\
        local arg1, arg2, arg3 = ...\
        for i = 1, 3 do\
          local trimmed = arg1:gsub("^ +", "")\
          local item = factory.item_names[trimmed]\
          if not item then\
            return "Can't find " .. trimmed\
          end\
          category[name1] = item.id\
          name1, name2, name3 = name2, name3\
          arg1, arg2, arg3 = arg2, arg3\
        end\
      end\
    )}

    ; Define a new production item with name "name", craftable from tiers 1-"tiers".
    ; The string passed to produce() is "game_name".
    ; It will take the next available id, starting from 1.
    #item(name, tiers, game_name) {lua(\
      return factory.add_item("{name}", {tiers}, {game_name}, "item")\
    )}

    ; Define a new production item with name "name", craftable from tiers 1-"tiers".
    ; The string passed to craft() is "game_name".
    ; It will take the next available id, starting from 1.
    #make(name, tiers, game_name) {lua(\
      return factory.add_item("{name}", {tiers}, {game_name}, "craft")\
    )}

    ; Define a new item group, i.e. a set of items designed to be scanned in the
    ; crafter. Because items need a valid game_name to be passed to count() in
    ; various places (or else there will be spurious logging), we use "ore".
    ; (The value returned from count() will always be ignored.)
    #group(name, tiers) {lua(\
      return factory.add_item("{name}", {tiers}, "ore", "group")\
    )}

    ; Defines a "special" item. This has a real name, like an item, but acts
    ; like an item-group in other ways. This is used for lumps and ore, which
    ; require special-case handling.
    #special(name, tiers, game_name) {lua(\
      return factory.add_item("{name}", {tiers}, {game_name}, "special")\
    )}

    ; Defines a category grouping for the UI. "First" and "last" are the span of
    ; the group (inclusive), in item names. Must be called *after* the relevant items
    ; are defined.
    #category(name, default, first, last) {lua(\
      return factory.add_category("{name}", "{default}", "{first}", "{last}")\
    )}
  }
  worker_storage_lib: {
    ; This library will find a slot in the pool of workers to use as "permanent storage".
    ; If one doesn't already exist with the given tag, a new one will be allocated,
    ; *but* it will avoid overwriting other worker names using the same sytem of tags
    ; for storage. Thus, scripts can use this to cooperate without having to
    ; explicitly assign worker slot numbers.
    ;
    ; The scheme is that a name will be prefixed with "[TOKEN]", where "TOKEN" is
    ; some short, unique word that will identify the script in question. For instance,
    ; the factory might use the word "factory".
    ;
    ; This library does not actually store anything in the worker name. Instead, it
    ; sets the variable "worker_slot", which you must declare in your code.
    ; If worker_slot < 100, then it found a valid slot with the worker_prefix.
    ; If 100 <= worker_slot < 200, then there was no existing slot, but new data
    ; can be initialized at (worker_slot - 100). If worker_slot == 200, then there
    ; are no available slots at all, and you should show an error message or take
    ; approriate action.
    ;
    ; A complete example looks like this (replace angle brackets with curlies):
    ;
    ; :local int worker_slot
    ; <worker_lib_line_1([TOKEN])>
    ; <worker_lib_line_2>

    ; =================================================================================

    #worker_prefix {lua(return worker_lib_prefix)}
    #worker_lacks_prefix sub(worker.name(worker_slot), 0, {len({worker_prefix})}) != "{worker_prefix}"

    ; The first macro, which defines the first line and the loop variable that we
    ; jump to. We also store the worker_prefix with Lua, so that we don't need to
    ; repeat it on the 2nd macro.
    ; We don't want to skip slot 0. Doing it like this saves a line.
    #worker_lib_line_1(worker_prefix_arg) {lua(\
      worker_lib_prefix = "{worker_prefix_arg}"\
    )}\
    find_worker_slot_loop: worker_slot = worker_slot + if({worker_lacks_prefix}, 1, 0)

    ; The second macro, which iterates until we're done.
    ; The test against worker.group() checks for non-existant workers. They would
    ; otherwise show as acceptable candidates, and we need to keep iterating to 200
    ; in that case.
    #worker_lib_line_2 gotoif(find_worker_slot_loop,\
      worker_slot < 100 && {worker_lacks_prefix} ||\
      worker_slot >= 100 && worker_slot < 200 && (worker.group(worker_slot - 100) == -1 || contains("[", sub(worker.name(worker_slot - 100), 0, 1)))\
    )
  }
  recipes: {
    :import factory constants

    {lua(\
      factory.recipes = {};\
    )}

    ; Infrastructure for defining the recipe list.
    {lua(\
      function factory.recipe(item)\
        local recipe_item = factory.item_names[item];\
        if not recipe_item then\
          return "Unknown item '" .. item .. "'";\
        end\
        if recipe_item.recipes then\
          return "Duplicate recipe for '" .. item .. "'";\
        end\
        factory.recipe_item = recipe_item;\
        local offset = 10 * recipe_item.id;\
        --[[There are two types of recipe list that we store: A "forward" list stored\
            on the item itself, which records what items are needed to *make* that\
            item, and a "reverse" list stored on the main factory object and indexed\
            by queue id, which records what items can be *made from* the item.\
            The forward list is used by the item group system, while the reverse list\
            is used by the recipe system proper.]]\
        for i = offset, offset + recipe_item.tier - 1 do\
          if not factory.recipes[i] then\
            factory.recipes[i] = {};\
          end\
        end\
        recipe_item.recipes = {};\
        for i = 1, recipe_item.tier do\
          recipe_item.recipes[i] = {};\
        end\
      end\
    \
      function factory.component(tiers, item_name, counts)\
        local recipe_item = factory.recipe_item;\
        if not recipe_item then\
          return "Tried to define a component before calling recipe!"\
        end\
        local item_name = item_name:gsub(" ", "");\
        local item = factory.item_names[item_name];\
        if not item then\
          return "Unknown item '" .. item_name .. "'";\
        end\
        if item.craft_type == "group" then\
          return string.format(\
            [[Cannot add item "%s" because it is a group]],\
            item.name,\
            recipe_item.name,\
            recipe_item.craft_type\
          );\
        end\
        local tier_tmp = {};\
        for word in tiers:gmatch("%S+") do\
          local tier = tonumber(word);\
          if not tier then\
            return "Bad tier " .. word\
          end\
          tier_tmp[#tier_tmp + 1] = tier;\
        end\
        if #tier_tmp ~= 1 and #tier_tmp ~= recipe_item.tier then\
          return "Tiers list has wrong size, item " ..\
            recipe_item.name .. " has " .. recipe_item.tier .. " tiers";\
        end\
        \
        local base_tier;\
        for i = 1, recipe_item.tier do\
          base_tier = tier_tmp[i] or base_tier;\
          local tier = base_tier;\
          if tier < 1 then\
            tier = tier + i;\
          end\
          tier_tmp[i] = tier;\
        end\
        \
        local counts_tmp = {};\
        for word in counts:gmatch("%S+") do\
          local count = tonumber(word);\
          if not count then\
            return "Bad count " .. word\
          end\
          counts_tmp[#counts_tmp + 1] = count;\
        end\
        if #counts_tmp ~= 1 and #counts_tmp ~= recipe_item.tier then\
          return "Counts list has wrong size, item " ..\
            recipe_item.name .. " has " .. recipe_item.tier .. " tiers";\
        end\
        for i = #counts_tmp + 1, recipe_item.tier do\
          counts_tmp[i] = counts_tmp[i-1];\
        end\
        --[[Finally, merge the two expanded lists and distribute the results\
            across the recipes for each tier. These recipes are "reversed,"\
            in the sense that they don't describe how to make each item, but\
            rather all the items that this one can be used to help make.\
            It's this reversed list that is needed for computing the material\
            needs when crafting.]]\
        local recipes = factory.recipes;\
        local offset = recipe_item.id * 10 - 1;\
        for i = 1, recipe_item.tier do\
          local tier = tier_tmp[i];\
          local count = counts_tmp[i];\
          if count > 0 and tier > 0 then\
            --[[Tiers less than 1 can happen naturally, due to the negative tier\
                convention, so they are silently dropped. Tiers greater than the\
                the maximum number of tiers are an error.]]\
            if tier > item.tier then\
              return "Tier " .. tier .. " > item max tier " .. item.tier;\
            end\
            local idx = item.id * 10 + tier - 1;\
            local comp = recipes[idx];\
            if comp == nil then\
              comp = {};\
              recipes[idx] = comp;\
            end\
            comp[#comp + 1] = offset + i;\
            comp[#comp + 1] = count;\
            local item_recipe = recipe_item.recipes[i];\
            item_recipe[#item_recipe + 1] = idx;\
            item_recipe[#item_recipe + 1] = count;\
          end\
        end\
      end\
    \
      function factory.produce(item, source, mult, machine)\
        local recipe_item = factory.item_names[item];\
        if not recipe_item then\
          return "Unknown item '" .. item .. "'";\
        end\
        if recipe_item.recipes then\
          return "Duplicate recipe for '" .. item .. "'";\
        end\
        local source_item = factory.item_names[source];\
        if not source_item then\
          return "Unknown item '" .. source .. "'";\
        end\
        if source_item.tier ~= recipe_item.tier then\
          return "Tier mismatch: " .. source .. "(" .. source_item.tier ..\
            ") vs " .. item .. "(" .. recipe_item.tier .. ")"\
        end\
        if #factory.prods == 0 or factory.prods[#factory.prods].machine ~= machine then\
          if factory.prod_machines[machine] then\
            return "Found 2nd group for machine '" .. machine .. "'";\
          end\
          factory.prod_machines[machine] = #factory.prods + 1;\
          factory.prod_machines[#factory.prod_machines + 1] = machine;\
        end\
        local prod = {};\
        prod.item = recipe_item;\
        prod.source = source_item;\
        prod.mult = mult;\
        prod.machine = machine;\
        factory.prods[#factory.prods + 1] = prod;\
    \
        local offset = 10 * source_item.id;\
        local count = 1 / mult;\
        for i = offset, offset + recipe_item.tier - 1 do\
          if not factory.recipes[i] then\
            factory.recipes[i] = {};\
          end\
          local recipe = factory.recipes[i];\
          recipe[#recipe + 1] = 10 * recipe_item.id - offset + i;\
          recipe[#recipe + 1] = count;\
        end\
        recipe_item.recipes = {};\
        for i = 1, recipe_item.tier do\
          local recipe = {};\
          recipe[1] = offset + i - 1;\
          recipe[2] = count;\
          recipe_item.recipes[i] = recipe;\
        end\
      end\
    \
      function factory.check_recipes()\
        for i = 1, #factory.items do\
          local item = factory.items[i];\
          if not item.recipes then\
            return item.name .. "(" .. item.id .. ") has no assigned recipe!";\
          end\
        end\
      end\
    )}

    ; Every recipe begins with this line. There must be one (and only one)
    ; recipe declaration for each item, even if there is no way to make it
    ; (like for rubber).
    #recipe(item) {lua(return factory.recipe([[{item}]]))}

    ; After starting a recipe, list its components with this. A component
    ; declares a single item that is used, and the the tiers and counts of that
    ; item for each tier of the recipe_item that's being made.
    ; The list on the left side is the tiers, the list on the right is the counts.
    ;
    ; For instance:
    ;  recipe(white_producer)
    ;  component(2 3 5 7 9, screw, 2 4 4 4 4)
    ; Means that a T1 white_producer needs 2 T2 screws, a T2 white_producer needs
    ; 4 T3 screws, T3 requires 4 T5 screws, etc.
    ; 
    ; There are additional space-saving wrinkles. Instead of repeating a number
    ; for every tier or every count when it's always the same, you can list it
    ; once. This is all-or-nothing: It must be exactly once, or listed once for
    ; every tier in the recipe.
    ; Also, in the tier list you can use numbers less than 1. This means that
    ; the position in the list will be added to the number. I.e. a value of
    ; 0 becomes equal to "current_tier", -1 becomes "current_tier - 1", etc.
    #component(tiers, item, counts) {lua(\
      return factory.component([[{tiers}]],[[{item}]],[[{counts}]]);\
    )}

    ; For items that are made in machines, use this macro instead. This defines
    ; the needed recipe automatically. The third argument is the "multiplier",
    ; which says how many multiples of the item are made from a single source
    ; input.
    ; It is assumed that the production happens for all tiers of the item,
    ; from the same source tier; things like mixing or boiling dust aren't handled
    ; through this system. (Boiling isn't handled at all.)
    #produce(item, source, mult, machine) {lua(\
      return factory.produce(\
        [[{item}]],\
        string.gsub([[{source}]], " ", ""),\
        {mult},\
        string.gsub([[{machine}]], " ", "")\
      );\
    )}

    ; ===== BEGIN RECIPES =====

    {recipe(town_producer)}
    {component(2 3 5 7 9, screw, 2 4 4 4 4)}
    {component(2 0 0 0 0, plate, 2 0 0 0 0)}
    {component(0 3 5 7 9, board, 0 2 2 2 6)}
    {component(-1, chip, 0 2 2 2 4)}
    {component(-1, town_producer, 1)}

    {recipe(factory_producer)}
    {component(1 3 5 7 9, wire, 1 4 4 4 4)}
    {component(2 0 0 0 0, screw, 1 0 0 0 0)}
    {component(0 3 5 7 9, board, 0 1 1 1 3)}
    {component(2 3 5 0 0, plate, 2 2 2 0 0)}
    {component(0 0 0 7 9, dense_plate, 0 0 0 2 4)}
    {component(1 1 2 3 4, chip, 2 1 1 1 3)}
    {component(-1, factory_producer, 1)}

    {recipe(mine_producer)}
    {component(2 3 5 7 9, screw, 2 2 2 4 4)}
    {component(1 2 4 6 8, wire, 2 3 2 5 5)}
    {component(2 0 5 7 9, plate, 1 0 1 2 2)}
    {component(0 3 5 7 9, dense_plate, 0 2 2 2 2)}
    {component(1 1 2 3 4, chip, 1)}
    {component(-1, mine_producer, 1)}

    {recipe(workshop_producer)}
    {component(0 2 4 6 8, wire, 0 4 2 8 8)}
    {component(1 3 5 7 9, wire, 4 2 2 2 2)}
    {component(2 3 5 7 9, plate, 1 2 2 2 2)}
    {component(1 0 2 3 4, chip, 1 0 2 2 2)}
    {component(-1, workshop_producer, 1)}

    {recipe(construction_firm_producer)}
    {component(2 4 6 8 10, rod, 3 4 10 10 10)}
    {component(2 4 6 8 10, plate, 2)}
    {component(1 1 2 3 4, chip, 1 2 2 2 2)}
    {component(-1, construction_firm_producer, 1)}

    {recipe(laboratory_producer)}
    {component(0 3 5 7 9, pipe, 0 3 5 10 14)}
    {component(2 4 6 8 10, motor, 1)}
    {component(1 3 5 7 9, dense_plate, 2 2 4 4 6)}
    {component(0, chip, 3 2 4 4 6)}
    {component(-1, laboratory_producer, 1)}

    {recipe(headquarters_producer)}
    {component(1 3 5 7 9, wire, 2 4 8 8 12)}
    {component(2 4 6 8 10, motor, 1 2 2 2 2)}
    {component(0, chip, 3 2 4 4 6)}
    {component(-1, headquarters_producer, 1)}

    {recipe(powerplant_producer)}
    {component(1 3 5 7 9, insul_cable, 2 2 4 4 6)}
    {component(2 4 6 8 10, motor, 1)}
    {component(0 3 5 7 9, block, 0 3 5 5 14)}
    {component(0, chip, 3 2 4 4 6)}
    {component(-1, powerplant_producer, 1)}

    {recipe(arcade_producer)}
    {component(2 4 6 8 9, insul_cable, 4 6 6 6 6)}
    {component(2 4 6 8 10, pipe, 4 4 4 4 8)}
    {component(0, chip, 4 4 4 4 6)}
    {component(-1, arcade_producer, 1)}

    {recipe(tradingpost_producer)}
    {component(2 4 6 8 10, ring, 6 8 8 8 12)}
    {component(2 4 6 8 10, plate, 4)}
    {component(0, chip, 2 2 2 2 4)}
    {component(-1, tradingpost_producer, 1)}

    {recipe(shipyard_producer)}
    {component(2 4 6 8 10, insul_cable, 6 8 8 8 12)}
    {component(1 3 5 7 9, block, 4)}
    {component(0, chip, 2 2 2 2 4)}
    {component(-1, shipyard_producer, 1)}

    {recipe(museum_producer)}
    {component(3 5 7 9 10, insul_cable, 6 7 7 7 9)}
    {component(2 4 6 8 10, block, 4 5 5 5 7)}
    {component(0, chip, 2 2 2 2 4)}
    {component(-1, museum_producer, 1)}

    {recipe(statue_of_cubos_producer)}
    {component(1 3 5 7 9, dense_block, 4 5 5 5 7)}
    {component(2 4 6 8 10, motor, 2)}
    {component(2 4 6 8 10, pipe, 2)}
    {component(2 4 6 8 10, pump, 2 3 3 3 5)}
    {component(0, chip, 2 2 2 2 4)}
    {component(-1, statue_of_cubos_producer, 1)}

    {recipe(gem_producer)}
    {component(5, chip, 10)}
    {component(4, chip, 10)}
    {component(10, insul_cable, 2)}
    {component(1, dense_block, 1)}
    {component(2, dense_block, 1)}
    {component(3, dense_block, 1)}
    {component(4, dense_block, 1)}
    {component(5, dense_block, 1)}
    {component(6, dense_block, 1)}
    {component(7, dense_block, 1)}
    {component(8, dense_block, 1)}
    {component(9, dense_block, 1)}
    {component(10, dense_block, 1)}

    {recipe(exotic_producer)}
    {component(5, chip, 10)}
    {component(10, insul_cable, 2)}
    {component(10, dense_block, 10)}
    {component(10, assembly, 1)}
    {component(10, boiler, 1)}
    {component(10, crusher, 1)}
    {component(10, cutter, 1)}
    {component(10, mixer, 1)}
    {component(10, oven, 1)}
    {component(10, presser, 1)}
    {component(10, refiner, 1)}
    {component(10, shaper, 1)}
    {component(10, belt, 1)}

    {recipe(acceleration_booster)}
    {component(2 3 5, chip, 1 4 6)}
    {component(4, plate, 4 0 0)}
    {component(1, rainbow_plate, 0 2 4)}
    {component(4 8 0, circuit, 4 8 0)}
    {component(10, dense_block, 0 0 12)}
    {component(1, void_essence, 0 0 4)}
    {component(-1, acceleration_booster, 2)}

    {recipe(machine_booster)}
    {component(2 3 5, chip, 2)}
    {component(4 7 10, pipe, 4)}
    {component(4, wire, 2 0 0)}
    {component(0 7 10, dense_block, 0 2 2)}
    {component(8, dense_plate, 0 6 0)}
    {component(1, rainbow_plate, 0 0 4)}
    {component(1, void_essence, 0 0 2)}
    {component(4, circuit, 1 0 0)}
    {component(-1, machine_booster, 1)}

    {recipe(production_booster)}
    {component(1 3 0, chip, 4 4 0)}
    {component(2 7 0, plate, 4 6 0)}
    {component(2 7 10, circuit, 1 4 4)}
    {component(10, dense_block, 0 0 12)}
    {component(1, void_essence, 0 0 4)}
    {component(-1, production_booster, 0 1 4)}

    {recipe(resource_booster)}
    {component(3, plate, 6 0 0)}
    {component(1, rainbow_plate, 0 0 2)}
    {component(1 3 4, chip, 2 2 6)}
    {component(4 8 0, circuit, 1 2 0)}
    {component(0 7 10, block, 0 4 4)}
    {component(1, void_essence, 0 0 1)}
    {component(-1, resource_booster, 0 1 2)}

    {recipe(pumpkin_producer)}
    {component(0, carved_pumpkin, 6)}
    {component(0, anti_pumpkin, 6)}
    {component(0, pumpkin_plate, 20)}

    {recipe(oven)}
    {component(0, plate, 4 6 8 8 8 8 8 8 8 8)}
    {component(0, insul_cable, 2 2 3 3 3 4 4 4 4 4)}
    {component(0, block, 0 0 0 0 0 2 2 2 2 2)}
    {component(-1, oven, 1)}

    {recipe(presser)}
    {component(1, hammer, 2 0 0 0 0 0 0 0 0 0)}
    {component(0, plate, 4 5 7 7 7 9 9 9 9 9)}
    {component(0, wire, 1 1 2 2 2 3 3 3 3 3)}
    {component(0, block, 0 0 0 0 4 5 5 5 5 5)}
    {component(1 1 1 2 2 2 3 3 4 4, chip, 2)}
    {component(-1, presser, 1)}

    {recipe(assembly)}
    {component(0, pipe, 1 1 1 1 1 2 2 2 2 2)}
    {component(0, dense_plate, 6 5 8 8 8 10 10 10 12 12)}
    {component(0, motor, 1 1 1 1 1 1 1 1 2 2)}
    {component(1 1 1 2 2 2 3 3 4 4, chip, 1 1 1 1 1 1 1 1 1 2)}
    {component(-1, assembly, 1)}

    {recipe(refiner)}
    {component(0, block, 0 0 0 0 0 0 5 5 5 7)}
    {component(0, dense_plate, 4)}
    {component(0, motor, 1 1 1 1 2 2 2 2 2 4)}
    {component(0, ring, 1 2 2 2 3 3 3 3 3 5)}
    {component(0, pump, 1 2 2 2 3 3 3 3 3 5)}
    {component(1 1 2 2 2 2 3 4 4 5, chip, 2)}
    {component(-1, refiner, 1)}

    {recipe(mixer)}
    {component(0, dense_plate, 5 4 4 5 5 6 6 6 6 6)}
    {component(0, motor, 2)}
    {component(0, pump, 1 1 1 2 2 3 3 3 3 3)}
    {component(1 1 1 2 2 2 2 3 4 4, chip, 1 1 1 2 2 3 3 3 3 3)}
    {component(-1, mixer, 1)}

    {recipe(crusher)}
    {component(0, dense_plate, 7 8 8 8 8 8 8 9 9 9)}
    {component(0, motor, 1 1 1 1 1 1 1 2 2 2)}
    {component(1 1 1 2 2 2 2 2 4 4, chip, 1 2 2 2 2 2 2 3 3 3)}
    {component(-1, crusher, 1)}

    {recipe(belt)}
    {component(1, rubber, 3 4 4 4 4 0 0 0 0 0)}
    {component(1, rubber_plate, 0 0 0 0 0 4 5 5 5 5)}
    {component(0, motor, 3 3 3 3 3 3 4 4 4 4)}
    {component(0, insul_cable, 3 4 4 4 4 4 5 5 5 5)}
    {component(0 0 0 1 2 2 3 3 4 4, chip, 0 0 0 4 4 4 5 5 5 5)}
    {component(-1, belt, 1)}

    {recipe(cutter)}
    {component(0, plate, 2 2 2 2 2 2 2 0 0 0)}
    {component(0, dense_plate, 3 3 3 3 3 4 4 2 2 2)}
    {component(0, block, 0 0 0 0 0 0 0 4 4 6)}
    {component(0, motor, 3 4 4 4 4 5 5 5 5 7)}
    {component(-1, cutter, 1)}

    {recipe(shaper)}
    {component(0, plate, 4 4 4 4 4 4 4 4 4 0)}
    {component(0, dense_plate, 0 0 0 0 0 0 0 0 0 4)}
    {component(0, screw, 1 2 2 2 2 3 3 3 3 3)}
    {component(0, block, 1 2 2 2 2 3 3 3 3 0)}
    {component(0, dense_block, 0 0 0 0 0 0 0 0 0 5)}
    {component(0, motor, 2)}
    {component(0, insul_cable, 1 1 1 1 1 2 2 2 2 4)}
    {component(-1, shaper, 1)}

    {recipe(boiler)}
    {component(0, wire, 2 2 2 3 3 3 3 3 4 5)}
    {component(0, dense_plate, 2 2 2 3 3 3 3 3 4 5)}
    {component(0, block, 4 7 7 8 8 8 8 8 9 10)}
    {component(0, motor, 1 1 1 2 2 2 2 2 3 4)}
    {component(0, screw, 2)}
    {component(0, pump, 1)}
    {component(-1, boiler, 1)}

    {recipe(rainbow_dust)}
    {component(1, dust, 1)}
    {component(2, dust, 1)}
    {component(3, dust, 1)}
    {component(4, dust, 1)}
    {component(5, dust, 1)}
    {component(6, dust, 1)}
    {component(7, dust, 1)}
    {component(8, dust, 1)}
    {component(9, dust, 1)}
    {component(10, dust, 1)}

    {recipe(chip)}
    {component(1 3 5 7 9, circuit, 2)}
    {component(2 4 6 8 10, circuit, 2 4 4 2 2)}
    {component(1 3 5 7 9, board, 1 4 4 6 8)}
    {component(2 4 6 8 10, board, 1 2 2 6 8)}
    {component(-1, chip, 0 4 8 12 12)}

    {recipe(insul_cable)}
    {component(0, cable, 1 1 1 2 3 4 5 10 12 16)}
    {component(1, rubber, 1 2 0 0 0 0 0 0 0 0)}
    {component(1, rubber_plate, 0 0 2 4 6 8 10 10 12 16)}

    {recipe(stacked_plate)}
    {component(0, plate, 9)}

    {recipe(stacked_pumpkin)}
    {component(0, pumpkin, 9)}

    {recipe(motor)}
    {component(0, plate, 4)}
    {component(0, screw, 1)}
    {component(0, rod, 2)}
    {component(0, wire, 1)}
    {component(1, rubber, 1)}

    {recipe(pump)}
    {component(0, plate, 2)}
    {component(0, motor, 1)}
    {component(0, ring, 2)}
    {component(1, rubber_plate, 4)}

    {recipe(hammer)}
    {component(2, ingot, 6)}
    {component(2, rod, 1)}

    {recipe(block)}
    {component(0, dense_plate, 8 8 8 8 8 8 12 12 12 12)}

    {recipe(rubber_sapling)}
    {component(0, rubber, 8)}
    {component(9, ore, 1)}

    {recipe(void_sapling)}
    {component(1, rainbow_dust, 8)}
    {component(1, rubber_sapling, 1)}

    {recipe(producers)}
    #recipe_producers(x) \
    {component(0, town_producer, {x})}\
    {component(0, factory_producer, {x})}\
    {component(0, mine_producer, {x})}\
    {component(0, workshop_producer, {x})}\
    {component(0, construction_firm_producer, {x})}\
    {component(0, laboratory_producer, {x})}\
    {component(0, headquarters_producer, {x})}\
    {component(0, powerplant_producer, {x})}\
    {component(0, arcade_producer, {x})}\
    {component(0, tradingpost_producer, {x})}\
    {component(0, shipyard_producer, {x})}\
    {component(0, museum_producer, {x})}\
    {component(0, statue_of_cubos_producer, {x})}
    {recipe_producers(1)}

    {recipe(machines)}
    {component(0, oven, 1)}
    {component(0, presser, 1)}
    {component(0, assembly, 1)}
    {component(0, refiner, 1)}
    {component(0, mixer, 1)}
    {component(0, crusher, 1)}
    {component(0, belt, 1)}
    {component(0, cutter, 1)}
    {component(0, shaper, 1)}
    {component(0, boiler, 1)}

    {recipe(parts)}
    #recipe_parts \
    {component(0, insul_cable, 1)}\
    {component(0, stacked_plate, 1)}\
    {component(0, motor, 1)}\
    {component(0, pump, 1)}\
    {component(1, hammer, 0 1 0 0 0 0 0 0 0 0)}\
    {component(0, block, 1)}\
    {component(0, ingot, 1)}\
    {component(0, plate, 1)}\
    {component(0, dense_plate, 1)}\
    {component(0, dense_block, 1)}\
    {component(0, pipe, 1)}\
    {component(0, cable, 1)}\
    {component(0, wire, 1)}\
    {component(0, rod, 1)}\
    {component(0, ring, 1)}\
    {component(0, screw, 1)}\
    {component(0, board, 1)}\
    {component(0, circuit, 1)}\
    {component(0, rubber_plate, 1 0 0 0 0 0 0 0 0 0)}\
    {component(1, rubber_sapling, 0 0 0 0 0 0 0 0 1 0)}
    {recipe_parts}

    {recipe(chips)}
    {component(1, chip, 1)}
    {component(2, chip, 1)}
    {component(3, chip, 1)}
    {component(4, chip, 1)}
    {component(5, chip, 1)}

    {recipe(chip_and_prods)}
    {component(0, chip, 1)}
    {recipe_producers(1)}

    #recipe_machines_and_parts \
    {component(0, oven, 1)}\
    {component(1, presser, 0 1 0 0 0 0 0 0 0 0)}\
    {component(0, presser, 0 1 1 1 1 1 1 1 1 1)}\
    {component(0, assembly, 1)}\
    {component(0, refiner, 1)}\
    {component(0, mixer, 1)}\
    {component(0, crusher, 1)}\
    {component(0, belt, 1)}\
    {component(0, cutter, 1)}\
    {component(0, shaper, 1)}\
    {component(0, boiler, 1)}\
    {recipe_parts}

    {recipe(all)}
    {component(0, chip, 1 1 1 1 1 0 0 0 0 0)}
    {recipe_producers(1 1 1 1 1 0 0 0 0 0)}
    {recipe_machines_and_parts}

    ; Machine-produced items
    {recipe(ingot)} ; Has special-case producing code
    {component(0, dust, 1)}

    {produce(rainbow_ingot, rainbow_dust, 1, oven)}

    {produce(plate, ingot, 1, presser)}
    {produce(rainbow_plate, rainbow_ingot, 1, presser)}
    {produce(dense_plate, stacked_plate, 1, presser)}
    {produce(rubber_plate, rubber, 1, presser)}
    {produce(pumpkin_plate, stacked_pumpkin, 1, presser)}

    {produce(dense_block, block, 1, boiler)}
    {produce(anti_pumpkin, pumpkin, 1, boiler)}

    {produce(rod, ingot, 2, shaper)}
    {produce(pipe, plate, 1, shaper)}
    {produce(ring, rod, 1, shaper)}

    {produce(cable, ingot, 2, refinery)}
    {produce(board, plate, 1, refinery)}
    {produce(wire, cable, 1, refinery)}

    {produce(screw, rod, 4, cutter)}
    {produce(carved_pumpkin, pumpkin, 1, cutter)}

    {produce(circuit, cable, 1, assembler)}

    ; These recipes have special-case code to handle them, because of the
    ; complexities involved with choosing between ore and lumps for making dust.
    {recipe(lump)}
    {recipe(dust)}

    ; Terminal items, unable to be crafted.
    {recipe(ore)}
    {recipe(rubber)}
    {recipe(void_essence)}
    {recipe(pumpkin)}

    ; ===== END RECIPES =====

    {lua(return factory.check_recipes())}
  }
  run_recipes: {
    :import factory constants
    :import recipes

    :name {script_name(run_recipes)}

    ; Debugging function, kept in case of future problems.
    #debug_dump_recipes {lua(\
      acc = {};\
      for i = 1, #factory.items do\
        local item = factory.items[i];\
        acc[#acc+1] = string.format("%02d %-18s [", i, item.name);\
        for j = 1, item.tier do\
          if j ~= 1 then \
            acc[#acc+1] = string.format("\n%23s", "");\
        end\
          acc[#acc+1] = [[(]];\
          local recipe = factory.recipes[i * 10 + j - 1];\
          for k = 1, #recipe do\
            if k ~= 1 then \
              acc[#acc+1] = " ";\
            end\
            acc[#acc+1] = recipe[k];\
          end\
          acc[#acc+1] = [[)]];\
        end\
        acc[#acc+1] = [[]\n]];\
      end\
      return table.concat(acc);\
    )}

    ;{debug_dump_recipes}

    ; Now that all the recipes are defined, we have to put them in a valid order.
    ; We do this with a modified breadth-first-search, optimized around the
    ; structure of our data.
    ; Each item (which in this context is a type-tier pair, identified by
    ; the formula type * 10 + tier) is sequentially checked against a graph
    ; that is incrementally being formed. If all its recipe-items have already been
    ; satisfied (or it has none), then it is also satisfied, and (as long
    ; as it has recipe-items) it's put on a queue to be output. Otherwise, a count
    ; is kept of how many unsatisfied recipes it has, and an entry is made in each
    ; blocking recipe pointing back to this item.
    ; After each item, the queue is processed. The head of the queue is popped
    ; and gets the next sequential id; this is how the recipes get their order.
    ; Also, any items blocked on it will have their tallies decremented by one.
    ; If these go to zero, they are now satisfied and will be added to the queue
    ; to be output, as well.
    {lua(\
      local recipes_list = {};\
      factory.recipes_list = recipes_list;\
      local items = factory.items;\
      local recipes = factory.recipes;\
      local graph = {};\
      local queue = {};\
      \
      for tier = 10, 1, -1 do\
        for item_id = 1, #items do\
          local item = items[item_id];\
          local id = 10 * item_id + tier - 1;\
          local recipe = recipes[id];\
          if not recipe then\
            goto continue;\
          end\
          \
          local entry = graph[id];\
          if not entry then\
            entry = {};\
            entry.blocking = {};\
            graph[id] = entry;\
          end\
          \
          local blockers = 0;\
          if recipe then\
            for i = 1, #recipe, 2 do\
              local other = graph[recipe[i]];\
              if not other then\
                other = {};\
                other.blocking = {};\
                other.blockers = -1;\
                graph[recipe[i]] = other;\
              end\
              if other.blockers ~= 0 then\
                blockers = blockers + 1;\
                other.blocking[#other.blocking + 1] = id;\
              end\
            end\
          end\
          entry.blockers = blockers;\
          \
          if blockers == 0 then\
            queue[#queue + 1] = id;\
          end\
          \
          local q_front = 1;\
          while q_front <= #queue do\
            id = queue[q_front];\
            entry = graph[id];\
            recipes_list[#recipes_list + 1] = id;\
            \
            for i = 1, #entry.blocking do\
              local other = graph[entry.blocking[i]];\
              other.blockers = other.blockers - 1;\
              if other.blockers == 0 then;\
                queue[#queue + 1] = entry.blocking[i];\
              end;\
            end\
            q_front = q_front + 1\
          end\
          queue = {};\
          ::continue::\
        end\
      end\
    )}

    ; Debugging function, kept in case of future problems.
    #debug_dump_recipes_list {lua(\
      acc = {};\
      for i = 1, #factory.recipes_list do\
        local id = factory.recipes_list[i];\
        acc[#acc+1] = string.format("%03d:", id);\
        local recipe = factory.recipes[id];\
        for j = 1, #recipe do\
          acc[#acc+1] = string.format(" %3s", recipe[j]);\
        end\
        acc[#acc+1] = "\n";\
      end\
      return table.concat(acc);\
    )}

    ;{debug_dump_recipes_list}

    ; Constructs the data table that is used to create loop_data. See below
    ; for the format of this string. One difference is that in loop_data, 
    ; the previous item/current item index data is at the beginning and end of the
    ; string. Here, that is actually only stored once, and the sub() read window is
    ; expanded to overlap consequetive sections to pick up the previous item when
    ; reading the next.
    #get_data(num_terms) {lua(\
      local num_terms = {num_terms};\
      local num_terms_2 = num_terms * 2;\
      local recipe_limit = 0;\
      local acc_main = {};\
      local sub = string.sub;\
      \
      local multipliers = "0123a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z";\
      local mult_max = {};\
      \
      for i = 1, num_terms do\
        mult_max[i] = 0;\
      end\
      \
      acc_main[1] = [["___]];\
      for i = 1, #factory.recipes_list do\
        local id = factory.recipes_list[i];\
        local recipe = factory.recipes[id];\
        local item_id = id // 10;\
        local limit = (#recipe - 1) // num_terms_2;\
        if limit < 0 then\
          limit = 0;\
        end;\
        for j = 1, (limit + 1) * num_terms_2, 2 do\
          acc_main[#acc_main + 1] = (j < #recipe) and recipe[j] + 100 or "   ";\
          local mod = (j // 2) % num_terms + 1;\
          local mult = (j < #recipe) and recipe[j+1] * 4 or 0;\
          if mult > mult_max[mod] then\
            mult_max[mod] = mult;\
          end\
          acc_main[#acc_main + 1] = sub(multipliers, mult + 1, mult + 1);\
          if mod == num_terms then\
            acc_main[#acc_main + 1] = id + 100;\
            recipe_limit = recipe_limit + 1;\
          end\
        end\
      end\
      \
      factory.main_size = 4 * num_terms + 3;\
      acc_main[#acc_main + 1] = [["]];\
      factory.multipliers = {};\
      factory.num_terms = num_terms;\
      factory.recipe_limit = recipe_limit;\
      \
      for i = 1, num_terms do\
        if mult_max[i] >= #multipliers then\
          return "Multiplier limit exceeded at " .. i;\
        end\
        factory.multipliers[i] = sub(multipliers, 1, mult_max[i] + 1);\
      end;\
      return table.concat(acc_main);\
    )}

    #lookup_item {lua(\
      return factory.composite_string(\
        string.format(\
          [[s2i(sub(gsg({data_name}), %d * (i + 1), 2), -1) - 11]],\
          factory.main_size\
        ),\
        nil,\
        true --[[Get craft type info instead of tiers]]\
      );\
    )}

    ; Returns the set of lookup/multiplier terms that will be added in to form
    ; the base of the value. Most of the data for this is pre-comupted by
    ; get_data().
    #recipe_terms {lua(\
      acc = {};\
      for i = 1, factory.num_terms do\
        if i ~= 1 then\
          acc[#acc + 1] = [[ + ]];\
        end\
        \
        acc[#acc + 1] = string.format(\
          [[max(0., ceil(gdg({queue_str} . sub(loop_data, %d, 3)) *\
            i2d(index("%s", sub(loop_data, %d, 1), 0)) * 0.25))]],\
          factory.entry_size + 4 * i - 1,\
          factory.multipliers[i],\
          factory.entry_size + 4 * i + 2\
        );\
      end\
      return table.concat(acc);\
    )}

    ; This macro is used to test the type of an item, in order to efficiently
    ; disable the count. Item groups don't have a single real item associated,
    ; but the count() still has to count something real to avoid a spurious log line.
    ; Ore and lumps are also classified as groups so that they won't be counted,
    ; because they're treated specially.
    #item_type sub(loop_data, {lua(return factory.entry_size - 1)}, 1)

    ; These macros are used to test if the item is a dust. Dust gets its queue value
    ; inflated by one, which has the effect of always ending up with 1 at the end.
    ; (Although it doesn't prevent temporarily using all dust.)
    #recipe_item_trunc sub(loop_data, {lua(\
      return factory.entry_size + factory.main_size;\
    )}, 2)
    #item_trunc(item) "{lua(return factory.item_names["{item}"].id + 10)}"

    #prev_item sub(loop_data, {lua(return factory.entry_size)}, 3)
    #recipe_item sub(loop_data, {lua(\
      return factory.entry_size + factory.main_size;\
    )}, 3)
    ; The tier value is just the last digit of recipe_item
    #tier_value sub(loop_data, {lua(\
      return factory.entry_size + factory.main_size + 2;\
    )}, 1)
    #recipe_item_name sub(loop_data, 0, index(loop_data, " ", 0))
    #recipe_limit {lua(return factory.recipe_limit)}

    :global int factory_target
    :global double factory_target_amount

    ; We use the name of the data variable to pull double-duty as a
    ; hider for all the craft-queue variables.
    ; This macro gives a prettier name for the global data string.
    #data_name "<size=0><line-height=0>fdata"

    :local int i
    :local string loop_data

    ; Uncomment this for debugging. It needs to be before the data-hiding block.
    ; Also uncomment the line below.
    ;gss("debug", "")

    gss({data_name}, {get_data(4)})
    loop:

    ; Evaluates to an expression that results in an string containing encoded data
    ; for this recipe. The first entry_size-1 characters are the in-game item name,
    ; space-padded. Then comes the item type info: 0 is a regular item, 1 is a
    ; crafted item, and 2 is an item-group. After that is a series of 3-number
    ; strings, each of which is a craft-queue index.
    ; The first is the index for the previous item, which is used to determine if
    ; this is a continuation from a previous line. The next `num_terms`
    ; terms are index values for queue values to add. After each term is a single
    ; character which is a multiplier value. Following that is an index for the
    ; current item, which is used as the index to set, and possibly also as an
    ; index to read from.
    ;
    ; All of this is pulled from reading the appropriate sections of "data", mostly
    ; as-is. However, there is a secondary lookup for the item name.
    loop_data = {lookup_item} . sub(\
      gsg({data_name}),\
      i * {lua(return factory.main_size)},\
      {lua(return factory.main_size + 3)}\
    )

    ; The core expression that does all the work. If this item is the target item,
    ; then set the queue value to factory_target_amount - this ensures that the
    ; target is always made, even if it already exists.
    ; Otherwise, we set it to the sum of all of its recipe terms, minus the existing
    ; count. This core value is the "queue value", and equals how many must be
    ; crafted (if positive) or how many extra we have (if negative).
    ; Since we are hardcoding the number of recipe terms that are handled in each
    ; loop iteration to a small constant (4), there are additional wrinkles because
    ; we may need to process the same item multiple times to get all the recipe
    ; terms in. This means that if we're seeing the same item again, we add the
    ; previous value of the variable and skip subtracting the count.
    ; We also skip the count if the item is a group, since those don't have valid
    ; items to count anyway.
    ; In this way, we efficiently encode a sum that requires multiple passes.
    {set_raw((-100) . {recipe_item}, \
      if({recipe_item} == i2s(factory_target + 100),\
        factory_target_amount,\
        (\
          if({prev_item} == {recipe_item}, {get_raw((-100) . {recipe_item})}, 0.) +\
          {recipe_terms} -\
          if(\
            {prev_item} == {recipe_item} || {item_type} == "2",\
            0.,\
            if({recipe_item_trunc} == {item_trunc(dust)}, -1., 0.) + count({recipe_item_name}, index(" 0123456789", {tier_value}, 0))\
          )\
        )\
      )\
    )}

    i = i + 1
    ; Uncomment this line for debugging. It will show the quantities and ids of all
    ; items that need to be produced. (The ids will be +100, because of internal reasons.)
    ; You will also need to enable another line above.
    ;gss("debug", gsg("debug") . if(gdg({queue_str} . {recipe_item}) > 0., "<br>" . {recipe_item} . " " . gdg({queue_str} . {recipe_item}), ""))
    gotoif(loop, i < {recipe_limit})

    ; inv_tier = 10 - tier. Represented this way so we can use the fact that locals
    ; automatically start at 0.
    :local int inv_tier

    tierloop:

    {add_queue(10 - inv_tier, dust, max(0., ({get_queue(10 - inv_tier, lump)} - count("lump", 10 - inv_tier)) * 4.0))}
    {add_queue(10 - inv_tier, ore, max(0., min(count("ore", 10 - inv_tier), ceil({get_queue(10 - inv_tier, dust)} / 2.))))}

    gotoif(nolumps, inv_tier == 9 || count("ore", 10 - inv_tier) + count("dust", 10 - inv_tier) == 0.)
    {add_queue(9 - inv_tier, lump, max(0., {get_queue(10 - inv_tier, dust)} - {get_queue(10 - inv_tier, ore)} * 2.))}
    nolumps:

    inv_tier += 1
    gotoif(tierloop, inv_tier < 10)

    ; If we're missing the resources needed to complete the recipe, set error.
    gss(\
      {action},\
      if(\
        {get_queue(1, ore)} * 2. < {get_queue(1, dust)},\
        "<color=#fb3>Missing " . ({get_queue(1, dust)} - {get_queue(1, ore)} * 2.) . " T1 dust<br>and/or higher tier dust/ore!</color>",\
        if(\
          {get_queue(1, rubber)} > 0.,\
          "<color=#fb3>Missing " . {get_queue(1, rubber)} . " rubber!</color>",\
          if(\
            {get_queue(1, void_essence)} > 0.,\
            "<color=#fb3>Missing " . {get_queue(1, void_essence)} . " void essence!</color>",\
            if(\
              {get_queue(1, pumpkin)} > 0.,\
              "<color=#fb3>Missing " . {get_queue(1, pumpkin)} . " pumpkin(s)!</color>",\
              ""\
            )\
          )\
        )\
      )\
    )

    :local int k
    unset_loop:
    ; If there's an error, clear the queue. We take advantage of initial value being 0 to
    ; cut down on lines. The first item is (raw) id 110, corresponding to
    ; 100 offset + 1 * 10, so we start at 109 as a no-op. We don't use unset here to avoid
    ; reordering issues with other scripts; all the global variables we will ever need to
    ; hide will have been set by this point, and we don't want to leave holes.

    ; Note that it is important to skip setting variables that are 0, since those might
    ; be tiers that are never calculated - in those cases, they would be new variables
    ; outside the hiding block if we set them here (after the first run of the factory).
    global.double.set({queue_str} . (109 + k), 0.)
    skip_unset:
    k += 1
    gotoif(\
      if(global.double.get({queue_str} . (109 + k)) == 0., skip_unset, unset_loop),\
      contains(gsg({action}), "<") && k < {lua(return #factory.items * 10 + 1)}\
    )

    gss("fhide2", "</line-height></size>")
  }
  produce: {
    :import factory constants
    :import recipes

    :name {script_name(produce)}

    :local int i
    :local int machine_idx
    :local double previous_amount
    :local string machine_chunk
    :local string machine_name
    :local string produce_data
    :local string source_name_raw

    key.{left}()
    key.{right}()

    isopen("factory")

    ; If we were launched via key impulse, invoke the UI immediately to start turbo,
    ; and set action to signal which key was pressed. Otherwise, we're being called
    ; as a produce script.
    execute(if(contains(impulse(), "key."), "{script_name(ui)}", "###badname###"))
    gotoif(end, contains(impulse(), "key."))

    ; ================== BEGIN MACROS + LUA ==================
    ; The data for producing is defined in a single string, stored in
    ; produce_data. Each entry in the string is a "produce_chunk", defined
    ; in the following format:
    ; MULT SOURCE_CHAR DEST_ITEM
    ; DEST_ITEM is a 3-byte number, denoting the raw queue value for the item.
    ; (I.e. after the +100 addition.) SOURCE_CHAR is a single character that
    ; is used for indexing a separate lookup table of the source item names.
    ; (The source tier will be the same as the tier of DEST_ITEM.) The MULT
    ; is a single number used when items produce multiple output copies.
    #produce_chunk_size 5

    ; Here we precompute all our data tables. There are three tables:
    ; produce_data, which stores the produce chunks described above.
    ; item_names, which stores destination item names only, and
    ; machine_data, which stores a combination of machine name and offset into produce_data.
    ;
    ; We also compute the character lookup table that is used to convert DEST_ITEM to/from
    ; numbers for use with item_names.
    {lua(\
      local format = string.format\
    \
      machine_chunk_size = nil\
      machine_data = nil\
      item_names = nil\
      item_names_size = nil\
      trans_table = "0123456789abcdefghijklmnopqrstuvwxyz"\
      produce_data = nil\
    \
      local function pad_strings(arr)\
        local max = 0\
        for i = 1, #arr do\
          max = max >= #arr[i] and max or #arr[i]\
        end\
        max = max + 1\
        local fmt_str = format("%%%ds", -max)\
        local res = {}\
        for i = 1, #arr do\
          res[i] = format(fmt_str, arr[i])\
        end\
        return res, max\
      end\
    \
      local machine_acc = {}\
      local item_acc = {}\
      local prod_acc = {}\
      local prods_offset = 1\
      local offsets = {}\
      factory.prod_machines[#factory.prod_machines + 1] = "end"\
      factory.prod_machines["end"] = #factory.prods + 1\
      for i = 1, #factory.prod_machines do\
        local machine = factory.prod_machines[i]\
        machine_acc[i] = machine\
        local next_offset = factory.prod_machines[machine]\
        for j = 1, 10 do\
          for k = prods_offset, next_offset - 1 do\
            local prod = factory.prods[k]\
            if prod.source.tier < j then goto continue end\
            local source_name = prod.source.game_name\
            if not item_acc[source_name] then\
              item_acc[#item_acc + 1] = source_name\
              item_acc[source_name] = #item_acc\
            end\
            prod_acc[#prod_acc + 1] = prod.mult ..\
              string.sub(trans_table, item_acc[source_name], item_acc[source_name]) ..\
              prod.item.id * 10 + 100 + j - 1\
            ::continue::\
          end\
        end\
        offsets[i] = format("%03d", #prod_acc * 5)\
        prods_offset = next_offset\
      end\
      if #prod_acc * 5 > 999 then\
        return "Offset overflows three digits: " .. table.concat(offsets, " ")\
      end\
      machine_acc, machine_chunk_size = pad_strings(machine_acc)\
      for i = 1, #machine_acc do\
        machine_acc[i] = offsets[i] .. machine_acc[i]\
      end\
    \
      machine_data = table.concat(machine_acc)\
      machine_chunk_size = machine_chunk_size + 3\
      item_acc, item_names_size = pad_strings(item_acc)\
      item_names = table.concat(item_acc)\
      trans_table = string.sub(trans_table, 1, #item_acc)\
      produce_data = table.concat(prod_acc)\
    \
    --[[Debug functions, uncomment as needed]]\
    --[[return table.concat(prod_acc, ",")]]\
    )}

    ;{lua(return produce_data)}_
    ;{lua(return machine_data)}
    ;{lua(return item_names)}
    ;{lua(return trans_table)}_

    ; When it is loaded from produce_data, the value in produce_data is
    ; processed from the raw produce_chunk to lookup the SOURCE_CHAR from the
    ; secondary lookup table. This still needs extra processing to trim the
    ; trailing spaces, which is why the source_name macro exists.
    #dest_offset 2
    #source_char_offset 1
    #mult_offset 0
    #get_source_tier index(" 0123456789", sub(produce_data, {dest_offset} + 2, 1), 0)
    #source_name sub(source_name_raw, 0, index(source_name_raw, " ", 0))
    #mult s2d(sub(produce_data, {mult_offset}, 1), 0.)

    #next_offset s2i(sub(machine_chunk, {lua(return machine_chunk_size)}, 3), 0)

    ; Raw access to the queue. This is even more direct than
    ; get_raw, because we're using queue strings directly.
    #raw_dest sub(produce_data, {dest_offset}, 3)
    #get_dest global.double.get({queue_str} . {raw_dest})
    #set_dest(value) global.double.set({queue_str} . {raw_dest}, {value})
    ; ================== END MACROS + LUA ==================

    executesync("{script_name(produce dust)}")
    stop("{script_name(produce dust)}")

    machine_loop:
    ; Setup machine data variables and set the produce index to the proper place.
    ; We break this out into separate variables because we don't run through this
    ; section as much (only once per machine, so ~8 times), and it makes the later
    ; expressions more efficient. Also, we have lines to spare.
    ; We get 3 extra characters after the machine chunk so that we have the next
    ; offset available as well, which we use to determine when to finish the produce_loop
    ; below and procede to the next machine.
    machine_chunk = sub("{lua(return machine_data)}", machine_idx, {lua(return machine_chunk_size)} + 3)
    machine_name = sub(machine_chunk, 3, index(machine_chunk, " ", 0) - 3)
    i = s2i(sub(machine_chunk, 0, 3), 0)
    machine_idx += {lua(return machine_chunk_size)}

    ; We need to setup the production data anyway, so we branch there. This is
    ; one instruction less efficient than other methods, but it lets us
    ; reuse a lot of code so it's worth it.
    goto(if(\
      contains("end", machine_name),\
      end,\
      set_data\
    ))

    produce_loop:
    source_name_raw = sub(\
      "{lua(return item_names)}",\
      index(\
        "{lua(return trans_table)}",\
        sub(produce_data, {source_char_offset}, 1),\
        0\
      ) * {lua(return item_names_size)},\
      {lua(return item_names_size)}\
    )

    ; Uncomment this line for runtime production debugging.
    ; You will also need to uncomment the line in run_recipes that unhides debug.
    ;gss("debug", gsg("debug") . "<br>" . {source_name} . {get_source_tier} . "_" . min(ceil({get_dest} / {mult}), count({source_name}, {get_source_tier})) . machine_name)

    ; Just try to produce. There is a wrinkle here not present when crafting:
    ; we take the minimum with the source count, so that we can use items as
    ; quickly as they become available. We only craft the entire quantity, to
    ; avoid needlessly filling the inventory.
    produce(\
      {source_name},\
      {get_source_tier},\
      min(ceil({get_dest} / {mult}), count({source_name}, {get_source_tier})),\
      machine_name\
    )

    ; We can blindly subtract the number of items in the machine, because we've
    ; guaranteed via the guards on our loop that we exit as soon as the machine
    ; is active. This means the item in there *must* be the correct one, if the
    ; count is > 0.
    {set_dest({get_dest} - {mult} * machine.item.count(machine_name))}

    next_item:
    i += {produce_chunk_size}
    set_data:
    produce_data = sub("{lua(return produce_data)}", i, {produce_chunk_size})

    ; Go to the next machine if we're done with this set of machines, or the machine
    ; has become active. Otherwise, either produce the next item, or skip it if
    ; the quantity is <= 0.
    goto(if(\
      i >= {next_offset},\
      machine_loop,\
      if(\
        active(machine_name),\
        machine_loop,\
        if(\
          {get_dest} <= 0.,\
          next_item,\
          produce_loop\
        )\
      )\
    ))

    end:
    gss({action}, if(\
      contains(impulse(), "key."),\
      if(\
        contains(impulse(), "key.{left}"),\
        "1",\
        "-1"\
      ),\
      gsg({action})\
    ))
  }
  produce dust: {
    :import factory constants

    :name {script_name(produce dust)}

    :local int _tier
    :local double previous_amount

    _tier = _tier + 1
    previous_amount = count("ore", _tier)
    produce("ore", _tier, {get_queue(_tier, ore)}, "crusher")
    {subtract_queue(_tier, dust, (previous_amount - count("ore", _tier)) * 2.)}
    {subtract_queue(_tier, ore, previous_amount - count("ore", _tier))}

    gotoif(notierupdust, _tier >= 10 || {get_queue(_tier, lump)} <= 0. || active("mixer"))
    craft("lump", _tier, min(\
      min(\
        (count("dust", _tier) - 1.) / 4.,\
        count("dust", _tier + 1)\
      ),\
      {get_queue(_tier, lump)} - count("lump", _tier)\
    ))
    previous_amount = count("lump", _tier)
    produce("lump", _tier, min(previous_amount, {get_queue(_tier, lump)}), "mixer")
    {subtract_queue(_tier, dust, previous_amount - count("lump", _tier))}
    {subtract_queue(_tier, lump, previous_amount - count("lump", _tier))}
    notierupdust:

    gotoif(noproduceingot, active("oven") || (if(_tier == 10, 0., ({get_queue(_tier, lump)} - count("lump", min(_tier, 9)))) * 4. > 2. * min(0., count("dust", _tier) - ({get_queue(_tier, ingot)})) & count("dust", _tier) < 2. * ({get_queue(_tier, ingot)})))
    previous_amount = count("dust", _tier)
    produce("dust", _tier, min(previous_amount - 1., {get_queue(_tier, ingot)}), "oven")
    {subtract_queue(_tier, ingot, previous_amount - count("dust", _tier))}
    noproduceingot:

    goto(if(_tier >= 10, 99, 1))
  }
  craft: {
    :import recipes

    :name {script_name(craft)}

    :local double previous_amount
    :local int i
    :local string itemdata
    :local string group_data

    :global int factory_target

    key.{up}()
    key.{down}()

    isopen("factory")

    ; If we were launched via key impulse, invoke the UI immediately to start turbo,
    ; and set action to signal which key was pressed. Otherwise, we're being called
    ; as a produce script.
    execute(if(contains(impulse(), "key."), "{script_name(ui)}", "###badname###"))
    gotoif(group_abort, contains(impulse(), "key."))

    ; Craft all the items.
    craftitems_loop:
    itemdata = {lua(return factory.composite_string("i/10", "craft"))}

    do_craft:
    ; Because items and tiers start at 1, but i is zero-based, we have to add 1
    ; or (pre-multiplying, 10) in these expressions.
    ; However, tier is zero-based inside our indexing representation, so we don't
    ; add it there.
    previous_amount = count({get_name}, i%10 + 1)
    craft({get_name}, i%10 + 1, {get_raw(10 + i)})
    {set_raw(10 + i, {get_raw(10 + i)} - (count({get_name}, i%10 + 1) - previous_amount))}
    inc:
    ; This skips over tiers that don't exist for the given item, by using the
    ; tier data embedded in "itemdata".
    i = i + if(i2s(i%10) == {tiers_char}, 10 - i%10, 1)
    goto(if(i%10 != 0,\
        if({get_raw(10 + i)} > 0., do_craft, inc),\
        if(i < {items_count} * 10, craftitems_loop, crafting_done)))
    crafting_done:

    ; Uncomment these lines for runtime item quantity debugging.
    ; You will also need to uncomment the line in run_recipes that unhides debug.
    ;i = 10
    ;debug_loop:
    ;gss("debug", if(i == 10, "", gsg("debug") . if({get_raw(i)} > 0., "<br>" . i . " " . {get_raw(i)}, "")))
    ;i += 1
    ;gotoif(debug_loop, i < {lua(return #factory.items)} * 10 + 10)

    group_data = "{lua(\
      acc = {}\
      for i = 1, #factory.items do\
        local item = factory.items[i];\
        if item.craft_type ~= "group" then goto continue end\
        for j = 1, item.tier do\
          acc[#acc+1] = "|" .. (i * 10 + j + 99);\
          local recipe = item.recipes[j];\
          for k = 1, #recipe, 2 do\
            acc[#acc+1] = recipe[k] + 100;\
          end\
        end\
        ::continue::\
      end\
      acc[#acc+1] = "|";\
      return table.concat(acc);\
    )}"

    i = index(group_data, "|" . (factory_target + 100), 0) + 1
    check_group_loop:
    i += 3
    goto(if(\
      i < 4, group_abort,\
      if(\
        sub(group_data, i, 1) == "|", group_complete,\
        if(\
          gdg({queue_str} . sub(group_data, i, 3)) > 0., group_abort,\
          check_group_loop\
        )\
      )\
    ))

    group_complete:
    {set_raw(factory_target, 0.)}
    group_abort:
    gss({action}, if(\
      contains(impulse(), "key."),\
      if(\
        contains(impulse(), "key.{up}"),\
        "1",\
        "-1"\
      ),\
      gsg({action})\
    ))
  }
  init: {
    :import factory constants

    :name {script_name(init)}

    wakeup()
    open.factory()

    isopen("factory")

    :global double factory_target_amount
    :global int factory_target

    :global int turbo.cycles
    :global int turbo.cycles.max

    :local double target_value

    ; Run the UI, to display the current pending item.
    execute("{script_name(ui)}")

    ; Initial dispatch on entering the factory to determine if we are resuming
    ; a crafting operation or waiting to launch a new one. This is done outside
    ; of turbo, so that we never invoke turbo if we don't need to.
    gotoif(wait_loop, {get_raw(factory_target)} == 0.)

    ; The core factory cycle. We do each loop of factory production within
    ; one call of nested turbo start/stop, which executes within one frame.
    ;
    ; This loop handles both calculating recipes via "run_recipes"
    ; and crafting via "craft". This is done with conditional execution,
    ; in order to save lines for future possible features.
    begin_cycle:
    executesync("TE2.2:start")

    ; Here we up the number of cycles so that it will be enough to
    ; calculate the recipes or produce items. We intentionally have a
    ; frame break between the recipe calculation and the beginning of crafting
    ; to prevent jarring lag on startup.
    ; This formula ensures that we don't accidentally step on another script
    ; that needs more cycles, and also that we get the full amount of cycles
    ; even if something else started turbo before us.
    turbo.cycles.max = max(turbo.cycles.max, turbo.cycles + 4000)

    ; We have to save this, because the value can change as a result of executing
    ; later scripts.
    target_value = {get_raw(factory_target)}

    ; All conditional execution in the loop is behind this condition. If it
    ; is true, then we're here because of `ui`. Otherwise,
    ; this is a regular crafting iteration.

    ; There are extra checks for isopen("factory") here. The main check is at the
    ; bottom of the loop, but that happens before the end of the frame, so there will
    ; be one more frame where we have exited the factory, but the loop still runs.
    ; Normally, this wouldn't be an issue (all of the scripts will perform no actions
    ; and leave the variables in the same state), but "produce" and "craft" have a
    ; startup condition of isopen("factory"), since they do double-duty as UI impulse
    ; scripts as well.
    ; So, we have to protect them, otherwise executesync() will hang when it hits
    ; the false condition, leading to a stuck script.
    executesync(if(\
      isopen("factory"),\
      if(target_value > 0., "{script_name(produce)}", "{script_name(run_recipes)}"),\
      "{garbage_requested}"\
    ))
    stop(if(target_value > 0., "{script_name(produce)}", "{script_name(run_recipes)}"))
    executesync(if(\
      target_value > 0. && isopen("factory"),\
      "{script_name(craft)}",\
      "{garbage_requested}"\
    ))
    stop(if(target_value > 0., "{script_name(craft)}", "{garbage_requested}"))

    ; Clear factory_target to indicate that crafting is done, if it is, in fact, done.
    factory_target = if({get_raw(factory_target)} > 0., factory_target, 0)
    ; Re-display the UI when crafting is done.
    execute(if(factory_target == 0, "{script_name(ui)}", "{garbage_requested}"))

    ; Clear this (unconditionally), to signal that we're not starting a new crafting
    ; pass.
    factory_target_amount = 0.

    executesync("TE2.2:stop")

    ; Here we either return to the next iteration of the production loop,
    ; or stall on this instruction until we need to launch the factory.
    ; Because there is always 1 extra cycle of turbo after "TE2.2:stop," there
    ; is enough time to execute this goto and have only a single frame break
    ; before starting turbo again at the top of the loop.
    wait_loop:
    gotoif(\
      if(max(factory_target_amount, {get_raw(factory_target)}) > 0.,\
        begin_cycle, wait_loop\
      ),\
      isopen("factory")\
    )

    ; Remove the UI status so it doesn't clutter the variables when we're outside the
    ; factory.
    ; This is safe to repeat, when turbo is looping at the end of the script.
    gss({status}, "</size>")
  }
  ui: {
    :import factory constants
    :import worker_storage_lib

    :name {script_name(ui)}

    :local double count
    :local int visible_tier
    :local int tier
    :local int category
    :local int item
    :local int cursor

    :global int turbo.cycles
    :global int turbo.register
    :global int factory_target
    :global double factory_target_amount

    key.{start}()

    isopen("factory")

    ; Because of how turbo exec works, we can't launch turbo on the frame the script
    ; starts by calling "TE2.2:start", if we are being called from another script.
    ; We can only do it by changing turbo.register directly, saving a layer of
    ; script execution.
    ; (This is because of the relative positioning of TE.turbo vs our script;
    ; usually we would be before, but when we are first launched our script is after.)
    turbo.register += 1

    ; Use worker_buffer to set the alocated space inside of the workers name
    :const int worker_buffer 9

    ; Use worker_storage_lib to find a worker_slot to use for permanent storage.
    :local int worker_slot
    {worker_lib_line_1([factory])}
    {worker_lib_line_2}

    ; Split out the worker data into separate variables. We take advantage of this
    ; time to also perform increment/decrement, since we can easily combine it in
    ; this stage. We don't bother checking if we've got a valid slot, because if we
    ; don't, we'll simply fail to parse and get the fallback value.

    #action_num s2i(gsg({action}), 0)
    ; Is the u/d action valid for this position?
    ; Using contains() instead of == and chained compares saves a lot of import space.
    #is_ud(pos) contains(impulse() . cursor, ":craft{pos}")

    #worker_tier     worker_buffer
    #worker_category worker_buffer + 1
    #worker_item     worker_buffer + 2
    #worker_cursor   worker_buffer + 4

    cursor = min(worker_buffer + 2, max(0, \
      s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + {worker_cursor}, 2), 0) + \
      if(contains(impulse(), "{script_name(produce)}"), {action_num}, 0)\
    ))

    count = min(10.0 ^ i2d(worker_buffer) - 1.0, max(1.0, \
      s2d(sub(worker.name(worker_slot), {len({worker_prefix})}, worker_buffer), 1.0) + \
      if(\
        contains(impulse(), "{script_name(craft)}"), \
        i2d({action_num}) * floor(10.0 ^ i2d(cursor - 3)), \
        0.0\
      )\
    ))

    #num_categories {lua(return #factory.categories)}
    category = (\
      s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + {worker_category}, 1), 0) - \
      if({is_ud(1)}, {action_num}, 0) + \
      {num_categories}\
    ) % {num_categories}

    ; Because math expressions are so expensive, in terms of import space, it's best
    ; to just pre-compute tables of the next/previous item to go to for every item.
    ; To avoid duplicating expressions, we also make a no-op table for the case where
    ; we're not incrementing or decrementing.
    {lua(\
      function factory.item_inc_table(inc)\
        local acc = {};\
        local default = string.format("%02d", factory.categories[1].default - 1);\
        for i = 1, #factory.categories do\
          local cat = factory.categories[i];\
          local cat_size = cat.last - cat.first + 1;\
          for j = cat.first, cat.last do\
            acc[j] = string.format("%02d", (j + inc - cat.first) % cat_size + cat.first - 1);\
          end\
        end\
        for i = 1, #factory.items do\
          acc[i] = acc[i] or default;\
        end\
        return table.concat(acc);\
      end\
    )}

    #item_inc_table(inc) {lua(return factory.item_inc_table({inc}))}
    #category_defaults {lua(\
      local acc = {};\
      for i = 1, #factory.categories do\
        acc[i] = string.format("%02d", factory.categories[i].default - 1);\
      end\
      return table.concat(acc);\
    )}

    ; Items in this variable are zero-indexed, as opposed to their regular ids, which
    ; start from 1.
    ; We increment the items in the opposite direction from the action, because pressing
    ; up (action 1) *increments* numerical values but *decrements* elements in an
    ; alphabetically sorted list.
    item = s2i(if(\
        {is_ud(1)}, \
        sub(\
          "{category_defaults}", \
          category * 2, \
          2\
        ), \
        sub(\
          if(\
            {is_ud(0)},\
            if(\
              contains(gsg({action}), "-1"),\
              "{item_inc_table(1)}", \
              "{item_inc_table(-1)}"\
            ), \
            "{item_inc_table(0)}"\
          ), \
          s2i(\
            sub(worker.name(worker_slot), {len({worker_prefix})} + {worker_item}, 2), \
            {lua(return factory.categories[1].default - 1)}\
          ) * 2, \
          2\
        )\
      ), \
      0\
    )

    ; The distinction between "tier" and "visible_tier" has to do with the fact that
    ; items have different tier maximums. When a user is scrolling through different
    ; items, if the "tier" is T10 (represented as "9" in our zero-indexed scheme),
    ; then the "visible_tier" will change to fit the maximum tier for the item, while
    ; the tier remains at T10. However, if the item is a producer (max of T5), and
    ; the user moves the cursor to the tier field and presses "W", the attempt to
    ; increment "tier" will fix it at a new value of T5 (4).
    #tier_data {lua(\
      local acc = {};\
      for i = 1, #factory.items do\
        local item = factory.items[i];\
        acc[i] = string.format("%d", item.tier - 1);\
      end\
      return table.concat(acc);\
    )}

    ; Expression to load the saved tier data from the worker name, including
    ; a default value when there is no data.
    #saved_worker_tier s2i(\
      sub(worker.name(worker_slot), {len({worker_prefix})} + {worker_tier}, 1), \
      0\
    )

    ; It makes the most sense to set visible_tier first. There is a complication
    ; when adjusting the tier down; in this case, we reduce the maximum bounds by
    ; one, so that (for instance) if the max tier is T5, and the current tier is T10,
    ; we'll properly clip the visible_tier to T4 after subtracting 1 to get T9.
    ; This type of adjustment isn't needed (or wanted) in the other direction, or
    ; when the tier isn't changing.
    visible_tier = max(0, min(\
      s2i(sub("{tier_data}", item, 1), {worker_item}) + \
        if({is_ud(2)} && contains("-1", gsg({action})), -1, 0), \
      {saved_worker_tier} + if ({is_ud(2)}, {action_num}, 0)\
    ))

    tier = if({is_ud(2)}, visible_tier, {saved_worker_tier})

    ; Finally, construct the visible name for use in the variable.
    {lua(\
      local names = {};\
      local name_starts = {};\
      local name_sizes = {};\
      local name_len = 0;\
    \
      for i = 1, #factory.items do\
        local name = factory.items[i].name;\
        names[i] = name;\
        name_starts[i] = string.format("%03d", name_len);\
        name_len = name_len + #name;\
        name_sizes[i] = string.format("%02d", #name);\
      end\
      factory.name_data = table.concat(names);\
      factory.name_starts = table.concat(name_starts);\
      factory.name_sizes = table.concat(name_sizes);\
      factory.items_count = #factory.items;\
    \
      names = {};\
      for i = 1, #factory.categories do\
        names[i] = factory.categories[i].name;\
      end\
      factory.category_names = table.concat(names);\
    )}


    #name_data      {lua(return factory.name_data)}
    #name_starts    {lua(return factory.name_starts)}
    #name_sizes     {lua(return factory.name_sizes)}
    #category_names {lua(return factory.category_names)}

    ; Set this variable in order to begin a variable-hiding block.
    ; It looks like a no-op, but really we're ensuring that it has a slot in the
    ; globals table, even if its value empty - in this case, what we care about
    ; is the *name*, which starts with "<size=0>".
    ; Do this *after* all the other work, to give turbo register time to
    ; set its variables, in case we're doing this right at startup.
    gss ({action}, gsg ({action}))

    ; Do conditional stuff, depending on if we're launching the factory.
    ; We set all these variables always, so that they'll have a consistent order,
    ; and also to save lines instead of jumping over this block.

    #valid_start contains (factory_target . impulse(), "0key.")
    ; This (maybe) launches the factory. We need to do it soon enough to not
    ; interrupt turbo, see the comment on "TE2.2:stop", below.
    {lua(\
      for i = 1, #factory.categories do\
        if factory.categories[i].name == "grup" then\
          group_concatination = i - 1;\
          return;\
        end\
      end\
      return "Couldn't find grup";\
    )}

    factory_target_amount = if(\
      {valid_start}, \
      count, \
      factory_target_amount\
    )


    ; Only set factory_target if it's zero, which indicates that the factory is idle.
    ; This prevents repeated keypresses from messing things up.
    factory_target = if({valid_start}, (item + 1) * 10 + visible_tier, factory_target)

    ; Construct the status line. There's a *lot* that goes into this.
    ;
    ; For starters, we fake the variable - it's not really "make", but rather a
    ; totally different variable that's less likely to collide. The true variable name
    ; is never seen, because it's still part of the <size=0> block. We put our fake
    ; variable name after. We do all this so that we can "unset" the variable by
    ; just changing its value - this way, it's not truly unset, and we don't have
    ; issues with variable ordering as a result.
    ;
    ; This also means we can change the variable name to something else, like
    ; "error", if we need to, all without actually creating a new variable or
    ; changing ordering.
    ;
    ; All the clauses are dynamically created on the fly here. We also create the
    ; "cursor" by highlighting a specific part of the result in green. This involves
    ; a great deal more complexity.
    #curs_col 2f4

    ; For later - scanning rework
    ;count_string if (category == {lua(return group_concatination)}, "  -SCAN-", d2s (10.0 ^ i2d({worker_tier}) + count))
    #count_string d2s (10.0 ^ i2d ({worker_tier}) + count)

    gss({status}, if(\
      worker_slot == 200, \
      "</size>error=<color=#fb3>No available workers!</color>", \
      if(\
        turbo.cycles == 0, \
        "</size>error=<color=#fb3>Turbo exec is not working</color>", \
        \
        "</size>make=<color=#fff>" . \
        sub ({count_string}, 1, {worker_item} - cursor) . \
        "</color><color=#{curs_col}>". \
        sub ({count_string}, {worker_item} + 1 - cursor, 1) . \
        "</color><color=#fff>". \
        sub ({count_string}, {worker_cursor} - cursor, {worker_item} + 1) . \
        "<smallcaps>x</smallcaps><color=#" . \
        if(cursor == 2, "{curs_col}>T", "fff>T") . (visible_tier + 1) . \
        if(cursor == 1, "</color> <color=#{curs_col}>", "</color> <color=#fff>") . \
        sub("{category_names}", category * 4, 4) . \
        if(\
          cursor == 0, \
          "</color> ...<br><color=#{curs_col}>", \
          "</color> ...<br><color=#fff>"\
        ) . sub(\
          "{name_data}", \
          s2i(sub("{name_starts}", item * 3, 3), 0), \
          s2i(sub("{name_sizes}", item * 2, 2), 0)\
        ) . "<br></color></color>" . if(\
          contains(impulse() . gsg({action}), "{script_name(init)}<"), \
          gsg({action}),\
          if(\
            factory_target == 0,\
            "<color=#0df>{up}{left}{down}{right} moves, {start} crafts</color> ",\
            "<color=#ff0>Crafting...</color>"\
          )\
        )\
      )\
    ))

    ; Pause/unpause a dissolve worker, if it occupies our data slot.
    ; If it's a different type of worker, leave it alone by dummying out the name.
    worker.pauseName(\
      if(\
        contains(worker.task(worker.name(worker_slot)), "factory.dissolveManagement"), \
        worker.name(worker_slot), \
        "{garbage_requested}"\
      ), \
      contains(gsg({status}), "Crafting")\
    )

    ; "init" will take over as soon as factory_target_amount gets set 4 lines
    ; above; it will call its own "TE2.2:start" and thus prevent the frame from
    ; ending before this line takes effect.
    ; We need two cycles in-between to have a seamless transition.
    ; We change the variable directly, instead of calling "TE2.2:stop", for parity
    ; with the way we start: This avoids some edge cases when turbo is incorrectly
    ; installed. It also is fine in this case, because we don't need to wait for
    ; the end of the frame.
    turbo.register = turbo.register - 1

    ; Setting the data back in the worker is moved way down to the bottom, to function
    ; as the "filler" action that can be repeated while the script is waiting for
    ; the frame to end. We can't use of the actions that set global variables for this,
    ; because they may need to be modified later in the frame, and thus setting them
    ; here in a loop would overwrite the value.
    worker.setName(if(worker_slot < 100, worker_slot, worker_slot - 100), \
      "{worker_prefix}" . \
      sub(d2s(10.0 ^ i2d(worker_buffer) + count), 1, worker_buffer) . tier . category . \
      sub(i2s(100 + item), 1, 2) . sub(i2s (100 + cursor), 1, 2)\
    )
  }
}