:import factory constants
:import recipes
:import worker_storage_lib

:budget_cap max

:name {script_name(main)}

wakeup()
open.factory()
key.{start}()
key.{left}()
key.{right}()
key.{up}()
key.{down}()

isopen("factory")

:global double factory_target_amount
:global int factory_target
:global int factory_craft_idx

:local double count
:local int visible_tier
:local int tier
:local int category
:local int item
:local int cursor

; ======================= UI =======================
ui:

; Use worker_storage_lib to find a worker_slot to use for permanent storage.
; On subsequent runs, this is a no-op.
:local int worker_slot
#worker_prefix [factory]
{worker_storage_lib({worker_prefix})}

; Split out the worker data into separate variables. We take advantage of this
; time to also perform increment/decrement, since we can easily combine it in
; this stage. We don't bother checking if we've got a valid slot, because if we
; don't, we'll simply fail to parse and get the fallback value.

; Is the u/d action valid for this position?
; Using contains() instead of == and chained compares saves a lot of import space.
#is_ud(pos) contains("key.{up}{pos}|key.{down}{pos}", impulse() . cursor)
#ud_offset if(contains(impulse(), "key.{up}"), 1, if(contains(impulse(), "key.{down}"), -1, 0))

cursor = min(9, max(0,\
  s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 11, 1), 0) +\
  if(contains(impulse(), "key.{left}"), 1, if(contains(impulse(), "key.{right}"), -1, 0))\
))
count = min(9999999., max(1.,\
  s2d(sub(worker.name(worker_slot), {len({worker_prefix})}, 7), 1.) +\
  i2d({ud_offset} * 10^(cursor - 3))\
))

#num_categories {lua(return #factory.categories)}
category = (\
  s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 8, 1), 0) -\
  if(cursor == 1, {ud_offset}, 0) +\
  {num_categories}\
) % {num_categories}

; Because math expressions are so expensive, in terms of import space, it's best
; to just pre-compute tables of the next/previous item to go to for every item.
; To avoid duplicating expressions, we also make a no-op table for the case where
; we're not incrementing or decrementing.
{lua(\
  function factory.item_inc_table(inc)\
    local acc = {}\
    local default = string.format("%02d", factory.categories[1].default - 1)\
    for i = 1, #factory.categories do\
      local cat = factory.categories[i]\
      local cat_size = cat.last - cat.first + 1\
      for j = cat.first, cat.last do\
        acc[j] = string.format("%02d", (j + inc - cat.first) % cat_size + cat.first - 1)\
      end\
    end\
    for i = 1, #factory.items do\
      acc[i] = acc[i] or default\
    end\
    return table.concat(acc)\
  end\
)}
#item_inc_table(inc) {lua(return factory.item_inc_table({inc}))}
#category_defaults {lua(\
  local acc = {}\
  for i = 1, #factory.categories do\
    acc[i] = string.format("%02d", factory.categories[i].default - 1)\
  end\
  return table.concat(acc)\
)}

; Items in this variable are zero-indexed, as opposed to their regular ids, which
; start from 1.
; We increment the items in the opposite direction from the action, because pressing
; up (action 1) *increments* numerical values but *decrements* elements in an
; alphabetically sorted list.
item = s2i(\
  if({is_ud(1)},\
    sub(\
      "{category_defaults}",\
      category * 2,\
      2\
    ),\
    sub(\
      if({is_ud(0)},\
        if(\
          contains(impulse(), "key.{down}"),\
          "{item_inc_table(1)}",\
          "{item_inc_table(-1)}"\
        ),\
        "{item_inc_table(0)}"\
      ),\
      s2i(\
        sub(worker.name(worker_slot), {len({worker_prefix})} + 9, 2),\
        {lua(return factory.categories[1].default - 1)}\
      ) * 2,\
      2\
    )\
  ),\
  0\
)

; The distinction between "tier" and "visible_tier" has to do with the fact that
; items have different tier maximums. When a user is scrolling through different
; items, if the "tier" is T10 (represented as "9" in our zero-indexed scheme),
; then the "visible_tier" will change to fit the maximum tier for the item, while
; the tier remains at T10. However, if the item is a producer (max of T5), and
; the user moves the cursor to the tier field and presses "W", the attempt to
; increment "tier" will fix it at a new value of T5 (4).
#tier_data {lua(\
  local acc = {};\
  for i = 1, #factory.items do\
    local item = factory.items[i];\
    acc[i] = string.format("%d", item.tier - 1);\
  end\
  return table.concat(acc)\
)}

; Expression to load the saved tier data from the worker name, including
; a default value when there is no data.
#saved_worker_tier s2i(sub(worker.name(worker_slot), {len({worker_prefix})} + 7, 1), 0)

; It makes the most sense to set visible_tier first. There is a complication
; when adjusting the tier down; in this case, we reduce the maximum bounds by
; one, so that (for instance) if the max tier is T5, and the current tier is T10,
; we'll properly clip the visible_tier to T4 after subtracting 1 to get T9.
; This type of adjustment isn't needed (or wanted) in the other direction, or
; when the tier isn't changing.
visible_tier = max(0,\
  min(s2i(sub("{tier_data}", item, 1), 9) +\
      if(contains("key.{down}2", impulse() . cursor), -1, 0),\
    {saved_worker_tier} + if(cursor == 2, {ud_offset}, 0)\
  )\
)
tier = if({is_ud(2)}, visible_tier, {saved_worker_tier})

; Save the data back in the worker.
worker.setName(if(worker_slot < 100, worker_slot, worker_slot - 100),\
  "{worker_prefix}" . sub(d2s(10000000. + count), 1, 7) . tier . category .\
  sub(i2s(100 + item), 1, 2) . cursor\
)

; Finally, construct the visible name for use in the variable.
{lua(\
  local names = {}\
  local name_starts = {}\
  local name_sizes = {}\
  local name_len = 0\
\
  for i = 1, #factory.items do\
    local name = factory.items[i].name\
    names[i] = name\
    name_starts[i] = string.format("%03d", name_len)\
    name_len = name_len + #name\
    name_sizes[i] = string.format("%02d", #name)\
  end\
  factory.name_data = table.concat(names)\
  factory.name_starts = table.concat(name_starts)\
  factory.name_sizes = table.concat(name_sizes)\
  factory.items_count = #factory.items\
\
  names = {}\
  for i = 1, #factory.categories do\
    names[i] = factory.categories[i].name\
  end\
  factory.category_names = table.concat(names)\
)}
#name_data {lua(return factory.name_data)}
#name_starts {lua(return factory.name_starts)}
#name_sizes {lua(return factory.name_sizes)}
#category_names {lua(return factory.category_names)}

; Set this variable in order to begin a variable-hiding block.
; It looks like a no-op, but really we're ensuring that it has a slot in the
; globals table, even if its value empty - in this case, what we care about
; is the *name*, which starts with "<size=0>".
; This could be moved higher if necessary.
gss({action}, gsg({action}))

; Another no-op just for variable hiding
factory_craft_idx = factory_craft_idx

; Do conditional stuff, depending on if we're launching the factory.
; We set all these variables always, so that they'll have a consistent order,
; and also to save lines instead of jumping over this block.

#valid_start contains(factory_target . impulse(), "0key.{start}")
; This (maybe) launches the factory.
{lua(\
  for i = 1, #factory.categories do\
    if factory.categories[i].name == "grup" then\
      grup_cat = i - 1;\
      return;\
    end\
  end\
  return "Couldn't find grup"\
)}
factory_target_amount = if(\
  {valid_start},\
  count,\
  factory_target_amount\
)

; Only set factory_target if it's zero, which indicates that the factory is idle.
; This prevents repeated keypresses from messing things up.
factory_target = if({valid_start}, (item + 1) * 10 + visible_tier, factory_target)

; Construct the status line. There's a *lot* that goes into this.
;
; For starters, we fake the variable - it's not really "make", but rather a
; totally different variable that's less likely to collide. The true variable name
; is never seen, because it's still part of the <size=0> block. We put our fake
; variable name after. We do all this so that we can "unset" the variable by
; just changing its value - this way, it's not truly unset, and we don't have
; issues with variable ordering as a result.
;
; This also means we can change the variable name to something else, like
; "error", if we need to, all without actually creating a new variable or
; changing ordering.
;
; All the clauses are dynamically created on the fly here. We also create the
; "cursor" by highlighting a specific part of the result in green. This involves
; a great deal more complexity.
#curs_col 2f4
; For later - scanning rework
;count_string if(category == {lua(return grup_cat)}, "  -SCAN-", d2s(10000000. + count))
#count_string d2s(10000000. + count)

gss({status}, if(\
  worker_slot == 200,\
  "</size>error=<color=#fb3>No available workers!</color>",\
  "</size>make=<color=#fff>" .\
  sub({count_string}, 1, 9 - cursor) .\
  "</color><color=#{curs_col}>".\
  sub({count_string}, 10 - cursor, 1) .\
  "</color><color=#fff>".\
  sub({count_string}, 11 - cursor, 10) .\
  "<smallcaps>x</smallcaps><color=#" .\
  if(cursor == 2, "{curs_col}>T", "fff>T") .\
  (visible_tier + 1) .\
  if(cursor == 1, "</color> <color=#{curs_col}>", "</color> <color=#fff>") .\
  sub("{category_names}", category * 4, 4) .\
  if(cursor == 0, "</color> ...<br><color=#{curs_col}>", "</color> ...<br><color=#fff>") .\
  sub("{name_data}", s2i(sub("{name_starts}", item * 3, 3), 0),\
    s2i(sub("{name_sizes}", item * 2, 2), 0)) .\
  "<br></color></color>" . if(\
    contains(gsg({action}), "<"),\
    gsg({action}),\
    if(\
      factory_target == 0,\
      "<color=#0df>{up}{left}{down}{right} moves, {start} crafts</color> ",\
      "<color=#ff0>Crafting...</color>"\
    )\
  )\
))

; Pause/unpause a dissolve worker, if it occupies our data slot.
; If it's a different type of worker, leave it alone by dummying out the name.
worker.pauseName(\
  if(\
    contains(worker.task(worker.name(worker_slot)), "factory.dissolveManagement"),\
    worker.name(worker_slot),\
    "![@#nosuchtask#@]!"\
  ),\
  contains(gsg({status}), "Crafting")\
)

; ======================= MAIN =======================

; Initial dispatch on entering the factory to determine if we are resuming
; a crafting operation or waiting to launch a new one.
; If we weren't invoked on startup/factory enter, this was just a temporary exec
; for the purposes of updated the UI.
goto(if(contains("wakeup|open.factory", impulse()), master_goto, end))

; The core factory cycle. We do each loop of factory production within
; budget, which executes within one frame.
;
; Craft will re-execute itself to get more budget, so that it can do all its work in
; one frame. This means that the frame crafting finishes, we will have already yielded
; via waitframe(), and won't find out about it until the *next* frame. However,
; craft will re-execute a copy of main to update the UI when it is done, so that happens
; on the same frame.
begin_cycle:
execute("{script_name(craft)}")

; Here we either return to the next iteration of the production loop,
; or stall on this instruction until we need to launch the factory.
wait_loop:
waitframe()

master_goto:
goto(if(\
  isopen("factory"),\
  if(\
    factory_target_amount > 0.,\
    run_recipes,\
    if(factory_target > 0, begin_cycle, wait_loop)\
  ),\
  clear_status\
))

; ========== BEGIN RUN_RECIPES ==========
run_recipes:

; Debugging function, kept in case of future problems.
#debug_dump_recipes {lua(\
  acc = {};\
  for i = 1, #factory.items do\
    local item = factory.items[i];\
    acc[#acc+1] = string.format("%02d %-18s [", i, item.name);\
    for j = 1, item.tier do\
      if j ~= 1 then acc[#acc+1] = string.format("\r%23s", "") end\
      acc[#acc+1] = "(";\
      local recipe = factory.recipes[i * 10 + j - 1];\
      for k = 1, #recipe do\
        if k ~= 1 then acc[#acc+1] = " " end\
        acc[#acc+1] = recipe[k];\
      end\
      acc[#acc+1] = ")";\
    end\
    acc[#acc+1] = "]\r";\
  end\
  return table.concat(acc);\
)}

;{debug_dump_recipes}

; Now that all the recipes are defined, we have to put them in a valid order.
; We do this with a modified breadth-first-search, optimized around the
; structure of our data.
; Each item (which in this context is a type-tier pair, identified by
; the formula type * 10 + tier) is sequentially checked against a graph
; that is incrementally being formed. If all its recipe-items have already been
; satisfied (or it has none), then it is also satisfied, and (as long
; as it has recipe-items) it's put on a queue to be output. Otherwise, a count
; is kept of how many unsatisfied recipes it has, and an entry is made in each
; blocking recipe pointing back to this item.
; After each item, the queue is processed. The head of the queue is popped
; and gets the next sequential id; this is how the recipes get their order.
; Also, any items blocked on it will have their tallies decremented by one.
; If these go to zero, they are now satisfied and will be added to the queue
; to be output, as well.
{lua(\
  local recipes_list = {};\
  factory.recipes_list = recipes_list;\
  local items = factory.items;\
  local recipes = factory.recipes;\
  local graph = {};\
  local queue = {};\
  for tier = 10, 1, -1 do\
    for item_id = 1, #items do\
      local item = items[item_id];\
      local id = 10 * item_id + tier - 1;\
      local recipe = recipes[id];\
      if not recipe then\
        goto continue;\
      end\
      local entry = graph[id];\
      if not entry then\
        entry = {};\
        entry.blocking = {};\
        graph[id] = entry;\
      end\
      local blockers = 0;\
      if recipe then\
        for i = 1, #recipe, 2 do\
          local other = graph[recipe[i]];\
          if not other then\
            other = {};\
            other.blocking = {};\
            other.blockers = -1;\
            graph[recipe[i]] = other;\
          end\
          if other.blockers ~= 0 then\
            blockers = blockers + 1;\
            other.blocking[#other.blocking + 1] = id;\
          end\
        end\
      end\
      entry.blockers = blockers;\
      \
      if blockers == 0 then\
        queue[#queue + 1] = id;\
      end\
      \
      local q_front = 1;\
      while q_front <= #queue do\
        id = queue[q_front];\
        entry = graph[id];\
        recipes_list[#recipes_list + 1] = id;\
        for i = 1, #entry.blocking do\
          local other = graph[entry.blocking[i]];\
          other.blockers = other.blockers - 1;\
          if other.blockers == 0 then;\
            queue[#queue + 1] = entry.blocking[i];\
          end;\
        end\
        q_front = q_front + 1\
      end\
      queue = {};\
      ::continue::\
    end\
  end\
)}

; Debugging function, kept in case of future problems.
#debug_dump_recipes_list {lua(\
  acc = {};\
  for i = 1, #factory.recipes_list do\
    local id = factory.recipes_list[i];\
    acc[#acc+1] = string.format("%03d:", id);\
    local recipe = factory.recipes[id];\
    for j = 1, #recipe do\
      acc[#acc+1] = string.format(" %3s", recipe[j]);\
    end\
    acc[#acc+1] = "\r";\
  end\
  return table.concat(acc);\
)}

;{debug_dump_recipes_list}

; Constructs the data table that is used to create loop_data. See below
; for the format of this string. One difference is that in loop_data,
; the previous item/current item index data is at the beginning and end of the
; string. Here, that is actually only stored once, and the sub() read window is
; expanded to overlap consequetive sections to pick up the previous item when
; reading the next.
#get_data(num_terms) {lua(\
  local num_terms = {num_terms};\
  local num_terms_2 = num_terms * 2;\
  local recipe_limit = 0;\
  local acc_main = {};\
  local sub = string.sub;\
  \
  local multipliers = "0123a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z";\
  local mult_max = {};\
  for i = 1, num_terms do\
    mult_max[i] = 0;\
  end\
  acc_main[1] = [["___]];\
  for i = 1, #factory.recipes_list do\
    local id = factory.recipes_list[i];\
    local recipe = factory.recipes[id];\
    local item_id = id // 10;\
    local limit = (#recipe - 1) // num_terms_2;\
    if limit < 0 then limit = 0 end;\
    for j = 1, (limit + 1) * num_terms_2, 2 do\
      acc_main[#acc_main + 1] = (j < #recipe) and recipe[j] + 100 or "   ";\
      local mod = (j // 2) % num_terms + 1;\
      local mult = (j < #recipe) and recipe[j+1] * 4 or 0;\
      if mult > mult_max[mod] then\
        mult_max[mod] = mult;\
      end\
      acc_main[#acc_main + 1] = sub(multipliers, mult + 1, mult + 1);\
      if mod == num_terms then\
        acc_main[#acc_main + 1] = id + 100;\
        recipe_limit = recipe_limit + 1;\
      end\
    end\
  end\
  \
  factory.main_size = 4 * num_terms + 3;\
  acc_main[#acc_main + 1] = '"';\
  factory.multipliers = {};\
  factory.num_terms = num_terms;\
  factory.recipe_limit = recipe_limit;\
  for i = 1, num_terms do\
    if mult_max[i] >= #multipliers then\
      return "Multiplier limit exceeded at " .. i;\
    end\
    factory.multipliers[i] = sub(multipliers, 1, mult_max[i] + 1);\
  end;\
  return table.concat(acc_main);\
)}

#lookup_item {lua(\
  return factory.composite_string(\
    string.format(\
      [[s2i(sub(gsg({data_name}), %d * (i + 1), 2), -1) - 11]],\
      factory.main_size\
    ),\
    nil,\
    true --[[Get craft type info instead of tiers]]\
  );\
)}

; Returns the set of lookup/multiplier terms that will be added in to form
; the base of the value. Most of the data for this is pre-comupted by
; get_data().
#recipe_terms {lua(\
  acc = {};\
  for i = 1, factory.num_terms do\
    if i ~= 1 then\
      acc[#acc + 1] = " + ";\
    end\
    acc[#acc + 1] = string.format(\
      [[max(0., ceil(gdg({queue_str} . sub(loop_data, %d, 3)) *\
        i2d(index("%s", sub(loop_data, %d, 1), 0)) * 0.25))]],\
      factory.entry_size + 4 * i - 1,\
      factory.multipliers[i],\
      factory.entry_size + 4 * i + 2\
    );\
  end\
  return table.concat(acc);\
)}

; This macro is used to test the type of an item, in order to efficiently
; disable the count. Item groups don't have a single real item associated,
; but the count() still has to count something real to avoid a spurious log line.
; Ore and lumps are also classified as groups so that they won't be counted,
; because they're treated specially.
#item_type sub(loop_data, {lua(return factory.entry_size - 1)}, 1)

; These macros are used to test if the item is a dust. Dust gets its queue value
; inflated by one, which has the effect of always ending up with 1 at the end.
; (Although it doesn't prevent temporarily using all dust.)
#recipe_item_trunc sub(loop_data, {lua(\
  return factory.entry_size + factory.main_size;\
)}, 2)
#item_trunc(item) "{lua(return factory.item_names["{item}"].id + 10)}"

#prev_item sub(loop_data, {lua(return factory.entry_size)}, 3)
#recipe_item sub(loop_data, {lua(\
  return factory.entry_size + factory.main_size;\
)}, 3)
; The tier value is just the last digit of recipe_item
#tier_value sub(loop_data, {lua(\
  return factory.entry_size + factory.main_size + 2;\
)}, 1)
#recipe_item_name sub(loop_data, 0, index(loop_data, " ", 0))
#recipe_limit {lua(return factory.recipe_limit)}

; We use the name of the data variable to pull double-duty as a
; hider for all the craft-queue variables.
; This macro gives a prettier name for the global data string.
#data_name "<size=0><line-height=0>fdata"

:local int i
:local string loop_data

; Uncomment this for debugging. It needs to be before the data-hiding block.
; Also uncomment the line below.
;gss("debug", "")

gss({data_name}, {get_data(4)})
loop:

; Evaluates to an expression that results in an string containing encoded data
; for this recipe. The first entry_size-1 characters are the in-game item name,
; space-padded. Then comes the item type info: 0 is a regular item, 1 is a
; crafted item, and 2 is an item-group. After that is a series of 3-number
; strings, each of which is a craft-queue index.
; The first is the index for the previous item, which is used to determine if
; this is a continuation from a previous line. The next `num_terms`
; terms are index values for queue values to add. After each term is a single
; character which is a multiplier value. Following that is an index for the
; current item, which is used as the index to set, and possibly also as an
; index to read from.
;
; All of this is pulled from reading the appropriate sections of "data", mostly
; as-is. However, there is a secondary lookup for the item name.
loop_data = {lookup_item} . sub(\
  gsg({data_name}),\
  i * {lua(return factory.main_size)},\
  {lua(return factory.main_size + 3)}\
)

; The core expression that does all the work. If this item is the target item,
; then set the queue value to factory_target_amount - this ensures that the
; target is always made, even if it already exists.
; Otherwise, we set it to the sum of all of its recipe terms, minus the existing
; count. This core value is the "queue value", and equals how many must be
; crafted (if positive) or how many extra we have (if negative).
; Since we are hardcoding the number of recipe terms that are handled in each
; loop iteration to a small constant (4), there are additional wrinkles because
; we may need to process the same item multiple times to get all the recipe
; terms in. This means that if we're seeing the same item again, we add the
; previous value of the variable and skip subtracting the count.
; We also skip the count if the item is a group, since those don't have valid
; items to count anyway.
; In this way, we efficiently encode a sum that requires multiple passes.
global.double.set({queue_str} . {recipe_item},\
  if({recipe_item} == i2s(factory_target + 100),\
    factory_target_amount,\
    (\
      if({prev_item} == {recipe_item}, global.double.get({queue_str} . {recipe_item}), 0.) +\
      {recipe_terms} -\
      if(\
        {prev_item} == {recipe_item} || {item_type} == "2",\
        0.,\
        if({recipe_item_trunc} == {item_trunc(dust)}, -1., 0.) + count({recipe_item_name}, index(" 0123456789", {tier_value}, 0))\
      )\
    )\
  )\
)
i = (i + 1) % {recipe_limit}
; Uncomment this line for debugging. It will show the quantities and ids of all
; items that need to be produced. (The ids will be +100, because of internal reasons.)
; You will also need to enable another line above.
;gss("debug", gsg("debug") . if(gdg({queue_str} . {recipe_item}) > 0., "<br>" . {recipe_item} . " " . gdg({queue_str} . {recipe_item}), ""))
gotoif(loop, i != 0)

; Clear this (unconditionally), to signal that we're not starting a new crafting
; pass.
factory_target_amount = 0.

; inv_tier = 10 - tier. Represented this way so we can use the fact that locals
; automatically start at 0. The loop is designed to return it to 0 at the end.
:local int inv_tier

tierloop:

{add_queue(10 - inv_tier, dust, max(0., ({get_queue(10 - inv_tier, lump)} - count("lump", 10 - inv_tier)) * 4.0))}
{add_queue(10 - inv_tier, ore, max(0., min(count("ore", 10 - inv_tier), ceil({get_queue(10 - inv_tier, dust)} / 2.))))}

gotoif(nolumps, inv_tier == 9 || count("ore", 10 - inv_tier) + count("dust", 10 - inv_tier) == 0.)
{add_queue(9 - inv_tier, lump, max(0., {get_queue(10 - inv_tier, dust)} - {get_queue(10 - inv_tier, ore)} * 2.))}
nolumps:

inv_tier = (inv_tier + 1) % 10
gotoif(tierloop, inv_tier != 0)

; If we're missing the resources needed to complete the recipe, set error.
gss(\
  {action},\
  if(\
    {get_queue(1, ore)} * 2. < {get_queue(1, dust)},\
    "<color=#fb3>Missing " . ({get_queue(1, dust)} - {get_queue(1, ore)} * 2.) . " T1 dust<br>and/or higher tier dust/ore!</color>",\
    if(\
      {get_queue(1, rubber)} > 0.,\
      "<color=#fb3>Missing " . {get_queue(1, rubber)} . " rubber!</color>",\
      if(\
        {get_queue(1, void_essence)} > 0.,\
        "<color=#fb3>Missing " . {get_queue(1, void_essence)} . " void essence!</color>",\
        if(\
          {get_queue(1, pumpkin)} > 0.,\
          "<color=#fb3>Missing " . {get_queue(1, pumpkin)} . " pumpkin(s)!</color>",\
          ""\
        )\
      )\
    )\
  )\
)

:local int k
k = 0
unset_loop:
; If there's an error, clear the queue. We take advantage of initial value being 0 to
; cut down on lines. The first item is (raw) id 110, corresponding to
; 100 offset + 1 * 10, so we start at 109 as a no-op. We don't use unset here to avoid
; reordering issues with other scripts; all the global variables we will ever need to
; hide will have been set by this point, and we don't want to leave holes.

; Note that it is important to skip setting variables that are 0, since those might
; be tiers that are never calculated - in those cases, they would be new variables
; outside the hiding block if we set them here (after the first run of the factory).
global.double.set({queue_str} . (109 + k), 0.)
skip_unset:
k += 1
gotoif(\
  if(global.double.get({queue_str} . (109 + k)) == 0., skip_unset, unset_loop),\
  contains(gsg({action}), "<") && k < {lua(return #factory.items * 10 + 1)}\
)
gss("fhide2", "</line-height></size>")
; Update the ui, to show crafting and/or error message.
; This will immediately dump us into the main crafting loop, since we can only
; reach this point from the main copy of the script.
goto(ui)

clear_status:
; Remove the UI status so it doesn't clutter the variables when we're outside the
; factory.
gss({status}, "</size>")
end:
